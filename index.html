<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">前端小白学习中</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面向对象总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/23/面向对象总结/" class="article-date">
  <time datetime="2018-10-23T02:54:52.000Z" itemprop="datePublished">2018-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/23/面向对象总结/">面向对象总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p> 对象继承的所有原型对象</p>
<h4 id="什么类型的对象既有prototype属性，又有proto属性"><a href="#什么类型的对象既有prototype属性，又有proto属性" class="headerlink" title="什么类型的对象既有prototype属性，又有proto属性"></a>什么类型的对象既有prototype属性，又有<strong>proto</strong>属性</h4><p>函数类型的对象</p>
<h4 id="直接继承Object-prototype-的对象有哪几种？"><a href="#直接继承Object-prototype-的对象有哪几种？" class="headerlink" title="直接继承Object.prototype 的对象有哪几种？"></a>直接继承Object.prototype 的对象有哪几种？</h4><p>new Object、{}、Math、函数.prototype(显示原型)</p>
<h4 id="instanceof运算符规则"><a href="#instanceof运算符规则" class="headerlink" title="instanceof运算符规则"></a>instanceof运算符规则</h4><p>判断左边对象的原型链中有没有右边构造函数的显示原型对象</p>
<h4 id="for-in-语句遍历对象时，继承的属性能不能遍历出来"><a href="#for-in-语句遍历对象时，继承的属性能不能遍历出来" class="headerlink" title="for in 语句遍历对象时，继承的属性能不能遍历出来"></a>for in 语句遍历对象时，继承的属性能不能遍历出来</h4><p>能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.it=&quot;科技&quot;;</span><br><span class="line">       var obj=&#123;</span><br><span class="line">           value:1</span><br><span class="line">       &#125;</span><br><span class="line">       for(var key in obj)&#123;</span><br><span class="line">           console.log(key);</span><br><span class="line">           ///打印结果：value 、it</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="in运算符作用"><a href="#in运算符作用" class="headerlink" title="in运算符作用"></a>in运算符作用</h4><p>判断一个对象能否使用某个属性</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>删除对象的某个属性</p>
<h4 id="hasOwnProperty和propertyIsEnumberable的异同"><a href="#hasOwnProperty和propertyIsEnumberable的异同" class="headerlink" title="hasOwnProperty和propertyIsEnumberable的异同"></a>hasOwnProperty和propertyIsEnumberable的异同</h4><p>前者只判断一个对象<strong>自己</strong>有没有某个属性，<br>而后者还要判断该对象的属性是不是可枚举的</p>
<h4 id="函数的length属性和arguments对象的length属性有什么区别？"><a href="#函数的length属性和arguments对象的length属性有什么区别？" class="headerlink" title="函数的length属性和arguments对象的length属性有什么区别？"></a>函数的length属性和arguments对象的length属性有什么区别？</h4><p>函数的length是用来获取形参个数的<br>arguments的length属性是用来获取实参个数的</p>
<h4 id="实例成员（静态成员）"><a href="#实例成员（静态成员）" class="headerlink" title="实例成员（静态成员）"></a>实例成员（静态成员）</h4><p>添加给类（构造函数）的属性和方法</p>
<h4 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h4><p>添加给实例自己的属性和方法，以及原型对象中的属性和方法</p>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><h4 id="预解析都做了什么？"><a href="#预解析都做了什么？" class="headerlink" title="预解析都做了什么？"></a>预解析都做了什么？</h4><ul>
<li>变量声明</li>
<li>函数声明</li>
<li>语法检测<h4 id="预解析时变量与变量重名是如何处理"><a href="#预解析时变量与变量重名是如何处理" class="headerlink" title="预解析时变量与变量重名是如何处理"></a>预解析时变量与变量重名是如何处理</h4>后面的忽略<h4 id="函数与函数重名时"><a href="#函数与函数重名时" class="headerlink" title="函数与函数重名时"></a>函数与函数重名时</h4>保留后面的函数<h4 id="函数执行时内部是否也存在预解析"><a href="#函数执行时内部是否也存在预解析" class="headerlink" title="函数执行时内部是否也存在预解析"></a>函数执行时内部是否也存在预解析</h4>存在<h4 id="函数执行时，形参赋值在预解析之前还是之后"><a href="#函数执行时，形参赋值在预解析之前还是之后" class="headerlink" title="函数执行时，形参赋值在预解析之前还是之后"></a>函数执行时，形参赋值在预解析之前还是之后</h4>之前<h4 id="写在非代码块中的函数声明式会被预解析吗"><a href="#写在非代码块中的函数声明式会被预解析吗" class="headerlink" title="写在非代码块中的函数声明式会被预解析吗"></a>写在非代码块中的函数声明式会被预解析吗</h4>在最新的浏览器中，<strong>函数名</strong>会被预解析<br>老版本浏览器（除了火狐），函数整体会被预解析<h4 id="函数声明式的特点"><a href="#函数声明式的特点" class="headerlink" title="函数声明式的特点"></a>函数声明式的特点</h4></li>
<li>以function开头定义，要么在全局定义，要么直接嵌套在另一个函数中</li>
<li>会被预解析</li>
<li>必须有名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function shengMingShi()&#123;</span><br><span class="line">	(function()&#123;</span><br><span class="line">		function shengMingShi()&#123;&#125;</span><br><span class="line">		&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="函数表达式的特点"><a href="#函数表达式的特点" class="headerlink" title="函数表达式的特点"></a>函数表达式的特点</h4><ul>
<li>要么在表达式中，要么在语句中</li>
<li>不会被预解析</li>
<li>名字可有可无</li>
<li>函数名只能在函数内部使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var biaoDaShi=function()&#123;&#125;;</span><br><span class="line">biaoDaShi(function biaoDaShi()&#123;&#125;);</span><br><span class="line">(function biaoDaShi&#123;&#125;());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特殊情况的函数表达式"><a href="#特殊情况的函数表达式" class="headerlink" title="特殊情况的函数表达式"></a>特殊情况的函数表达式</h4><ul>
<li>写在非函数代码块中</li>
<li>名字是必须的</li>
<li>名字会被预解析</li>
<li>函数名可以在外面使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	function teShuBiaoDaShi()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h4 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h4><p>变量的有效范围</p>
<h4 id="函数作用域规则"><a href="#函数作用域规则" class="headerlink" title="函数作用域规则"></a>函数作用域规则</h4><p>只有函数可以划分变量的作用域</p>
<h4 id="块级作用域规则"><a href="#块级作用域规则" class="headerlink" title="块级作用域规则"></a>块级作用域规则</h4><p>凡是代码块就可以划分变量的作用域</p>
<h4 id="词法作用域（静态作用域）规则"><a href="#词法作用域（静态作用域）规则" class="headerlink" title="词法作用域（静态作用域）规则"></a>词法作用域（静态作用域）规则</h4><p>访问一个变量，优先在当前执行环境中去找，找不到则去产生该执行环境的环境中去找，以此类推，直到全局执行环境</p>
<h4 id="全局变量的概念和定义方式"><a href="#全局变量的概念和定义方式" class="headerlink" title="全局变量的概念和定义方式"></a>全局变量的概念和定义方式</h4><ul>
<li>概念：在任何地方都可以使用的变量</li>
<li>定义方式：在函数外声明的变量，或者没有var定义的变量（这种定义变量的方式以后会废弃）<h4 id="局部变量的概念和定义方式"><a href="#局部变量的概念和定义方式" class="headerlink" title="局部变量的概念和定义方式"></a>局部变量的概念和定义方式</h4></li>
<li>概念:只在声明的地方可以使用的变量</li>
<li>定义方式：在函数内声明的变量<h4 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h4>变量从定义开始，到释放结束，中间存活的过程<h4 id="全局变量的生命周期"><a href="#全局变量的生命周期" class="headerlink" title="全局变量的生命周期"></a>全局变量的生命周期</h4>从定义开始，到页面卸载 消亡，中间存活的过程<h4 id="局部变量的生命周期"><a href="#局部变量的生命周期" class="headerlink" title="局部变量的生命周期"></a>局部变量的生命周期</h4>一般情况下，是从函数执行后，变量的声明开始，到函数函数执行完毕结束；但也有特殊情况，可能存在闭包引用了这个变量，那么这个变量的生命周期和闭包一样长<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4>可访问非自身局部变量的函数（函数内的函数）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/23/面向对象总结/" data-id="cjnl50y210006a8vcqosdo8h0" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原生js整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/18/原生js整理/" class="article-date">
  <time datetime="2018-10-18T01:35:23.000Z" itemprop="datePublished">2018-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/18/原生js整理/">原生js整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="js事件机制"><a href="#js事件机制" class="headerlink" title="js事件机制"></a>js事件机制</h4><ul>
<li>点击屏幕上一个按钮,事件是如何传播的?<br>捕获, 冒泡</li>
</ul>
<h4 id="js-bind-实现机制"><a href="#js-bind-实现机制" class="headerlink" title="js bind 实现机制"></a>js bind 实现机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 代码来自书籍《JavaScript模式》</span><br><span class="line">if (typeof Function.prototype.bind === &apos;undefined&apos;) &#123;</span><br><span class="line">  Function.prototype.bind = function (thisArgs) &#123;</span><br><span class="line">    var fn = this,</span><br><span class="line">        slice = Array.prototype.slice,</span><br><span class="line">        args = slice.call(arguments, 1)</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return fn.apply(thisArgs, args.concat(slice.call(arguments)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现vue中的on-emit-off-once-手写代码"><a href="#实现vue中的on-emit-off-once-手写代码" class="headerlink" title="实现vue中的on, emit, off, once, 手写代码"></a>实现vue中的on, emit, off, once, 手写代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 参照vue源码实现</span><br><span class="line">var EventEmiter = function () &#123;</span><br><span class="line">  this._events = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">EventEmiter.prototpye.on = function (event, cb) &#123;</span><br><span class="line">  if (Array.isArray(event)) &#123;</span><br><span class="line">    for (let i = 0, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      this.on(event[i], cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    (this._events[event] || (this._events[event] = [])).push(cb)</span><br><span class="line">  &#125;</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">EventEmiter.prototype.once = function (event, cb) &#123;</span><br><span class="line">  function on () &#123;</span><br><span class="line">    this.off(event, cb)</span><br><span class="line">    cb.apply(this, arguments)</span><br><span class="line">  &#125;</span><br><span class="line">  on.fn = cb</span><br><span class="line">  this.on(event, on)</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">EventEmiter.prototype.off = function (event, cb) &#123;</span><br><span class="line">  if (!arguments.length) &#123;</span><br><span class="line">    this._events = Object.create(null)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">  if (Array.isArray(event)) &#123;</span><br><span class="line">    for (let i = 0, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      this.off(event[i], cb)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">  if (!cb) &#123;</span><br><span class="line">    this._events[event] = null</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">  if (cb) &#123;</span><br><span class="line">    let cbs = this.length</span><br><span class="line">    while(i--) &#123;</span><br><span class="line">      if (cb === cbs[i] || cb === cb[i].fn) &#123;</span><br><span class="line">        cbs.splice(i, l)</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventAEmiter.prototype.emit = function (event) &#123;</span><br><span class="line">  let cbs = this._event[event]</span><br><span class="line">  let args = Array.prototype.slice.call(arguments, 1)</span><br><span class="line">  if (cbs) &#123;</span><br><span class="line">    for (let i = 0, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      cbs[i].apply(this.args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Object-prototype-toString-call-方法"><a href="#Object-prototype-toString-call-方法" class="headerlink" title="Object.prototype.toString.call()方法"></a>Object.prototype.toString.call()方法</h4><p>使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下： Object.prototype.toString.call(value)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 1.判断基本类型</span><br><span class="line">Object.prototype.toString.call(null) // [object Null]</span><br><span class="line">Object.prototype.toString.call(undefined) // [object Undefined]</span><br><span class="line">Object.prototpye.toString.call(&apos;abc&apos;) // [object String]</span><br><span class="line">Object.prototype.toString.call(123) // [object Number]</span><br><span class="line">Object.prototype.toString.call(true) // [object Boolean]  </span><br><span class="line"></span><br><span class="line">// 2.判断原生引用类型</span><br><span class="line">// 函数类型</span><br><span class="line">function fn () &#123;</span><br><span class="line">  console.log(&apos;test&apos;)</span><br><span class="line">&#125;</span><br><span class="line">Object.prototype..toString.call(fn) // [object Function]</span><br><span class="line">// 日期类型</span><br><span class="line">var date = new Date()</span><br><span class="line">Onject.prototype.toString.call(date) // [object Date]</span><br><span class="line">// 数组类型</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">Object.prototype.toString.call(arr) // [object Array]</span><br><span class="line">// 正则表达式</span><br><span class="line">var reg = /[hbc]at/gi</span><br><span class="line">Object.prototype.toString.call(reg) // [object RegExp]</span><br><span class="line">// 自定义类型</span><br><span class="line">function Person (name, age) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">var people = new Person(&apos;Lily&apos;, 20)</span><br><span class="line">Object.prototype.toString.call(people) // [object Object]</span><br><span class="line">// 很明显这种方法不能准确判断people是Person的实例,而只能用instanceof 操作符来进行判断</span><br><span class="line">console.log(people instanceof Person) // true</span><br><span class="line"></span><br><span class="line">// 3. 判断原生Json对象</span><br><span class="line">var isNativeJson = window.JSON &amp;&amp; Object.prototype.toString.call(JSON)</span><br><span class="line">console.log(isNativeJson)</span><br><span class="line">// 输出结果为 [object JSON],说明JSON是原生的,否则不是;</span><br><span class="line">// 注意: Object.prototype.toString()本身是允许被修改的,而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/18/原生js整理/" data-id="cjnl50y2y0007a8vcit9n7mxx" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-html代码实现一些符号" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/12/html代码实现一些符号/" class="article-date">
  <time datetime="2018-10-12T01:15:36.000Z" itemprop="datePublished">2018-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/12/html代码实现一些符号/">html代码实现一些符号</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在网站开发中常常需要用到一些特殊字符,如商标注册,版权等,以下表格列举常用的符号用HTML代码表示</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">&amp;lt</td>
<td style="text-align:center">小于号</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">&amp;gt</td>
<td style="text-align:center">大于号</td>
</tr>
<tr>
<td style="text-align:center">“”</td>
<td style="text-align:center">&amp;quot</td>
<td style="text-align:center">引号</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">&amp;amp</td>
<td style="text-align:center">可用与现实其他特殊字符</td>
</tr>
<tr>
<td style="text-align:center">®</td>
<td style="text-align:center">&amp;reg</td>
<td style="text-align:center">已注册</td>
</tr>
<tr>
<td style="text-align:center">©</td>
<td style="text-align:center">&amp;copy</td>
<td style="text-align:center">版权</td>
</tr>
<tr>
<td style="text-align:center">™</td>
<td style="text-align:center">&amp;trade</td>
<td style="text-align:center">商标</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">&amp;ensp</td>
<td style="text-align:center">半方大的空白</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">&amp;emsp</td>
<td style="text-align:center">全方大的空白</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">&amp;nbsp</td>
<td style="text-align:center">不断行的空白</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/12/html代码实现一些符号/" data-id="cjnl50y1r0001a8vc3zp0uho7" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试题整理-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/面试题整理-vue/" class="article-date">
  <time datetime="2018-10-10T06:20:33.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/面试题整理-vue/">面试题整理-vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h4><p>MVVM是Model-View-ViewModeld的缩写.MVVM是一种设计思想.</p>
<ul>
<li>Model层代表数据模型,也可以在Model中定义数据修改和操作的业务逻辑,</li>
<li>View层代表UI组件,负责将数据模型转化成UI展现出来,</li>
<li>ViewModel是同步View和Model的对象.<br>在MVVM架构下,View和Model之间并没有直接的联系,而是通过ViewModel进行交互,Model和ViewModel之间的交互是双向的,因此View的数据变化会同步到Model中,而Model的数据变化也会立即反应到View上.<br>ViewModel通过数据绑定把View层和Model层连接起来,而View和Model之间的同步工作是自动的,无需人为干涉.因此开发者只需关注业务逻辑,不需要手动操作DOM,不需要关注数据状态的同步问题,复杂的数据状态维护完全由MVVM来统一管理.</li>
</ul>
<h4 id="MVVM和MVC的区别"><a href="#MVVM和MVC的区别" class="headerlink" title="MVVM和MVC的区别"></a>MVVM和MVC的区别</h4><ul>
<li>相同点: 都是一种设计思想</li>
<li>不同点: <ul>
<li>MVC中的controller演变成MVVM中的ViewModel,</li>
<li>MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低,加载速度变慢,影响用户体验;以及当Model频繁发生改变,开发者需要主动更新到View</li>
</ul>
</li>
</ul>
<h4 id="vue-的优点是什么"><a href="#vue-的优点是什么" class="headerlink" title="vue 的优点是什么"></a>vue 的优点是什么</h4><ul>
<li>低耦合: 视图(View)可以独立于Model变化和修改,一个ViewModel可以绑定到不同的View上,当View变化的时候,Model可以不变,当Model变化的时候View也可以不变.</li>
<li>可重用性: 可以把一些视图逻辑放在一个VIewModel中,让很多View重用这段视图逻辑.</li>
<li>独立开发: 开发人员可以专注于业务逻辑和数据的开发(VIewModel), 设计人员可以专注于页面设计,使用Express Blend可以很容易设计界面并生成xml代码.</li>
<li>可测试: 界面素来是比较难于测试的,而现在测试可以针对ViewNode了来写.</li>
</ul>
<h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4><p>vue实例从创建到销毁的过程,就是生命周期.<br>八个阶段: 创建前后,载入前/后,更新前/后,销毁前/后</p>
<ul>
<li>创建前/后: 在beforeCreate阶段,vue实例的挂载元素<br>el和数据对象data都为undefined,还未初始化.在created阶段,vue实例的数据对象有data了,el还没有.</li>
<li>载入前/后: 在beforeMount阶段,vue实例的$el 和data都初始化了,但还是挂载之前为虚拟的dom节点,data.message还未替换.在mounted阶段,vue实例挂载完成,data.message成功渲染.</li>
<li>更新前/后: 当data变化时,会触发beforeUpdate和updated方法.</li>
<li>销毁前/后: 在执行destroy方法后,对data的改变不会再触发周期函数,说明此时vue实例已经解除了事件监听以及和dom的绑定,但是dom结构依然存在.</li>
</ul>
<p>生命周期的作用: 生命周期中有多个事件钩子,让我们在控制整个vue实例的过程时更容易形成良好的逻辑.</p>
<p>第一次页面加载会触发哪几个钩子: beforeCreate, created, beforeMount, mounted</p>
<p>DOM渲染完成的周期在哪个: mounted</p>
<p>每个周期具体适合哪些场景:</p>
<ul>
<li>beforeCreate: 可以在此处加个loading事件,加载实例时触发,</li>
<li>created: 初始化完成时的事件写在这里,若在这结束loading事件,异步请求也可以在这里调用</li>
<li>mounted: 挂载元素,获取DOM节点</li>
<li>updated: 如果 对数据统一处理,在这里写上相应函数</li>
<li>beforeDestroy: 可以做一个停止事件的确认框</li>
<li>nextTick: 更新数据后立即操作dom</li>
<li>arguments是一个伪数组,没有便利借口,不能遍历</li>
</ul>
<h4 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h4><ul>
<li>vue.js是采用数据劫持结合发布者-订阅者模式的方式,通过Object.defineProperty()来劫持各个属性的setter,getter,在数据变动时发布消息给订阅者,触发相应的监听回调.<br>具体步骤<ul>
<li>第一步: 需要observe的数据对象进行遍历递归,包括子属性对象的属性,都加上setter和getter这样的话,给这个对象的某个值赋值,就会触发setter</li>
<li>第二步: compile解析模板指令,将模板中的变量替换成数据,然后初始化熏染页面视图,并将每个指令对应的节点绑定更新函数,添加数据的订阅者,一旦数据有变动,收到通知,更新视图.</li>
<li>第三步: watcher订阅者是observer和compile之间通信的桥梁,主要做的事情是:<ul>
<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>
<li>自身必须有一个update()方法</li>
<li>带属性变动dep.notice()通知时,能调用自身的update()方法,并触发compile中绑定的回调,则功成身退.</li>
</ul>
</li>
<li>第四步: MVVM作为数据绑定的入口,整合observer, compile和watcher三者<br>通过observer来监听自己的model数据变化,通过compile来解释编译模板指令,最终利用watcher打起observer和compile之间通信桥梁,达到数据变化-&gt;视图更新; 视图交互变化(input) -&gt; 数据model变更的双向绑定效果</li>
</ul>
</li>
</ul>
<h4 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h4><h5 id="父组件与子组件之间的传值"><a href="#父组件与子组件之间的传值" class="headerlink" title="父组件与子组件之间的传值"></a>父组件与子组件之间的传值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 父组件通过标签上面定义传值</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 引入子组件</span><br><span class="line">  import Main from &apos;./main&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;parent&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        data: &apos;向子组件传递数据&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 初始化组件</span><br><span class="line">    components: &#123;</span><br><span class="line">      Main</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件通过props方法接收数据</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;sun&apos;,</span><br><span class="line">    props: [&apos;data&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 子组件通过$emit方法传递参数</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=&quot;sendMsgToParent&quot;&gt;向父组件传值&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 引入子组件</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: [&apos;message&apos;],</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sendMsgToParent() &#123;</span><br><span class="line">        this.$emit(&apos;listenToChildEvent&apos;, &apos;this message is from child&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 在父组件中监听自定义事件并添加一个响应该事件的处理方式</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Main v-bind:message=&quot;parentMsg&quot; v-on:listenToChildEvent=&quot;showMsgFromChild&quot;&gt;&lt;/Main&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/tempalte&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Main from &apos;./main&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;parent&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        parentMsg: &apos;hello, Child&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      Main</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      showMsgFromChild(data) &#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套路由怎么定义"><a href="#嵌套路由怎么定义" class="headerlink" title="嵌套路由怎么定义"></a>嵌套路由怎么定义</h4><p>在vue-router的参数中使用children配置,就可以实现路由嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 引入两个子组件</span><br><span class="line">import home from &apos;./home&apos;</span><br><span class="line">import game from &apos;./game&apos;</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    redirect: &apos;/home&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/home&apos;,</span><br><span class="line">    component: home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;/home/game&apos;,</span><br><span class="line">        component: game</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h4 id="怎么定义vue-router的动态路由-怎么获取传过来的动态参数"><a href="#怎么定义vue-router的动态路由-怎么获取传过来的动态参数" class="headerlink" title="怎么定义vue-router的动态路由?怎么获取传过来的动态参数?"></a>怎么定义vue-router的动态路由?怎么获取传过来的动态参数?</h4><ul>
<li>在router目录下的index.js文件中,对path属性加上/:id</li>
<li>使用router对象的params.id</li>
</ul>
<h4 id="vue-router有哪几种导航钩子"><a href="#vue-router有哪几种导航钩子" class="headerlink" title="vue-router有哪几种导航钩子"></a>vue-router有哪几种导航钩子</h4><p>三种</p>
<ul>
<li>全局导航钩子: router.beforeEach(to, from, next), 作用: 跳转前进行判断拦截</li>
<li>组件内的钩子</li>
<li>单独路由独享组件</li>
</ul>
<h4 id="scss是什么-在vue-cli中的安装使用步骤是-有哪几大特性"><a href="#scss是什么-在vue-cli中的安装使用步骤是-有哪几大特性" class="headerlink" title="scss是什么?在vue-cli中的安装使用步骤是?有哪几大特性?"></a>scss是什么?在vue-cli中的安装使用步骤是?有哪几大特性?</h4><ul>
<li>css的预编译</li>
<li>使用步骤:<ul>
<li>用npm下三个loader(sass-loader, css-loader, node-sass)<br>在build目录找到webpack.base.config.js,在extends属性中加一个拓展.scss</li>
<li>在上述文件中配置一个module属性</li>
<li>在组件的style标签上加上lang属性,例如: lang=”scss”</li>
</ul>
</li>
<li>特性:<ul>
<li>可以用变量, 例如:$变量名称=值 </li>
<li>可以用混合器</li>
<li>可以嵌套</li>
</ul>
</li>
</ul>
<h4 id="sass和less的区别"><a href="#sass和less的区别" class="headerlink" title="sass和less的区别"></a>sass和less的区别</h4><ul>
<li>都是动态的样式语言,是css预处理器,css上的一种抽象层.是一种特殊的语法/语言编译成css</li>
<li>区别:<ul>
<li>变量符不一样,less是@,sass是$</li>
<li>sass支持条件语句,可以使用if{}else{},for循环等等,而less不支持</li>
<li>sass是基于ruby的,是在服务端处理的,而less需要引入less.js来处理less代码输出css到浏览器</li>
</ul>
</li>
</ul>
<h4 id="axios是什么-怎么使用-描述使用它实现登录功能的流程"><a href="#axios是什么-怎么使用-描述使用它实现登录功能的流程" class="headerlink" title="axios是什么?怎么使用?描述使用它实现登录功能的流程"></a>axios是什么?怎么使用?描述使用它实现登录功能的流程</h4><p>请求后台资源的模块<br>npm install axios安装好,然后发送的是跨域,需在配置文件中config/index.js进行设置.<br>后台如果是Tp5则定义一个资源路由.js使用import导入,然后.get或.post.<br>返回在.then函数中,失败在.catch函数中</p>
<h4 id="axios-tp5进阶中-调用axios-post-‘api-user’-是进行的什么操作-axios-put-‘api-user-8’-呢"><a href="#axios-tp5进阶中-调用axios-post-‘api-user’-是进行的什么操作-axios-put-‘api-user-8’-呢" class="headerlink" title="axios + tp5进阶中,调用axios.post(‘api/user’)是进行的什么操作?axios.put(‘api/user/8’)呢?"></a>axios + tp5进阶中,调用axios.post(‘api/user’)是进行的什么操作?axios.put(‘api/user/8’)呢?</h4><ul>
<li>跨域</li>
<li>添加用户操作</li>
<li>更新操作</li>
</ul>
<h4 id="active-class是哪个组件的属性"><a href="#active-class是哪个组件的属性" class="headerlink" title="active-class是哪个组件的属性"></a>active-class是哪个组件的属性</h4><p>vue-router模块的router-link组件</p>
<h4 id="mint-ui是什么-怎么使用-说出至少三个组件的使用方法"><a href="#mint-ui是什么-怎么使用-说出至少三个组件的使用方法" class="headerlink" title="mint-ui是什么?怎么使用?说出至少三个组件的使用方法"></a>mint-ui是什么?怎么使用?说出至少三个组件的使用方法</h4><ul>
<li>基于vue的前端组件库</li>
<li>npm安装,import样式和js<ul>
<li>全局引入: vue.use(mintUI)</li>
<li>单个组件引入: import {组件} from ‘mint-ui’</li>
</ul>
</li>
<li>组件例举: <ul>
<li>Toast(‘获取成功’)</li>
<li>mint-header</li>
<li>mint-swiper</li>
</ul>
</li>
</ul>
<h4 id="封装vue组件的过程"><a href="#封装vue组件的过程" class="headerlink" title="封装vue组件的过程"></a>封装vue组件的过程</h4><p>封装组件可以解决传统项目效率低,难维护,复用性等问题.<br>使用vue.extend方法创建一个组件,然后使用vue.component方法注册组件.子组件需要数据,可以在props中接收定义,而子组件修改好数据后,想把数据传递给父组件,可以采用emit方法.</p>
<h4 id="vue-js对template编译过程"><a href="#vue-js对template编译过程" class="headerlink" title="vue.js对template编译过程"></a>vue.js对template编译过程</h4><p>首先转换成AST树,再得到render函数返回VNode(vue的虚拟DOM节点)<br>步骤: </p>
<ul>
<li>通过compile编译器把template变异成AST语法树(abstract syntax tree),compile是createCompiler的返回值,createCompiler是用以创建编译器的.另外compile还负责合并option.</li>
<li>AST会经过generate(将AST语法树转化成render function字符串的过程)得到render函数,render的返回值是VNode,VNode是vue的虚拟DOM节点,里面有(标签名,子节点,文本等等)</li>
<li>vue的历史记录: history记录中向前或者后退多少步</li>
</ul>
<h4 id="v-show和v-if指令的异同点"><a href="#v-show和v-if指令的异同点" class="headerlink" title="v-show和v-if指令的异同点"></a>v-show和v-if指令的异同点</h4><ul>
<li>实现手段<ul>
<li>v-show指令是通过修改元素的display属性为显示或隐藏</li>
<li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li>
</ul>
</li>
<li>编译过程<ul>
<li>v-if切换有一个局部编译/卸载的过程,切换过程中合适地销毁和重建内部的事件监听和子组件<br>v-show只是简单的css切换</li>
</ul>
</li>
<li>编译条件<ul>
<li>v-if是惰性的,如果初始条件为假,则什么也不做;只有在条件第一次变成真的时候才会开始局部编译(编译被缓存?编译被缓存后,然后再切换的时候进行局部卸载);</li>
<li>v-show是在任何条件下(首次条件是否为真)都被编译,然后被缓存,而且DOM元素保留</li>
</ul>
</li>
<li>性能消耗<ul>
<li>v-if有更高的切换消耗</li>
<li>v-show有更高的初始渲染消耗</li>
</ul>
</li>
<li>使用场景<ul>
<li>v-if适合运营条件不大可能改变</li>
<li>v-show适合频繁切换</li>
</ul>
</li>
</ul>
<h4 id="如何让css只在当前组件中起作用"><a href="#如何让css只在当前组件中起作用" class="headerlink" title="如何让css只在当前组件中起作用"></a>如何让css只在当前组件中起作用</h4><p>在当前组件的style标签中添加scoped属性</p>
<h4 id="lt-keep-alive-gt-lt-keep-alive-gt-的作用"><a href="#lt-keep-alive-gt-lt-keep-alive-gt-的作用" class="headerlink" title="&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用"></a>&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用</h4><p>使用该标签包裹动态组件时,会缓存<em>不活动</em>的组件实例,主要用于保留组件状态或避免重新渲染<br>eg: 用户在列表页查看详情时会频繁执行:详情-&gt;返回列表-&gt;详情-&gt;返回列表,在此,列表和详情都是一个频率很高的页面,就可以使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存列表,这样用户在返回列表时就可以快速从缓存中渲染,而不是重新渲染.</p>
<h4 id="vue-cli项目目录中src目录中每个文件夹和文件的作用"><a href="#vue-cli项目目录中src目录中每个文件夹和文件的作用" class="headerlink" title="vue-cli项目目录中src目录中每个文件夹和文件的作用"></a>vue-cli项目目录中src目录中每个文件夹和文件的作用</h4><ul>
<li>assets: 放置静态资源</li>
<li>components: 放置组件</li>
<li>router: 定义路由相关的配置</li>
<li>view: 视图</li>
<li>app.vue: 应用主组件</li>
<li>main.js: 入口文件</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/10/面试题整理-vue/" data-id="cjnl50y3i000aa8vc3wj4ftq2" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-react笔记整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/29/react笔记整理/" class="article-date">
  <time datetime="2018-05-29T06:30:48.000Z" itemprop="datePublished">2018-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/29/react笔记整理/">react笔记整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React-基础知识"><a href="#React-基础知识" class="headerlink" title="React 基础知识"></a>React 基础知识</h1><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>化生成package.json文件: npm init </li>
</ul>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><ul>
<li>安装react: npm install react –save</li>
<li>安装react-dom: npm install react-dom –save<ul>
<li>如果使用react-native 则安装react-native</li>
</ul>
</li>
<li>安装webpack: npm install webpack –save-dev</li>
<li>npm install webpack-dev-server 支持热加载</li>
<li>安装babel,将ES6 转化为ES5: npm install babel-core –save-dev</li>
<li>安装babel其他工具<ul>
<li>npm install babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-preset-react babel-preset-stage-2 babel-runtime babel-polyfill –save-dev</li>
</ul>
</li>
</ul>
<h4 id="配置项目运行命令"><a href="#配置项目运行命令" class="headerlink" title="配置项目运行命令"></a>配置项目运行命令</h4><p>在package.json中修改scripts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;webpack-dev-server --hot --inline --colors --content-base ./build&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack --progress --colors&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>运行项目: npm start</li>
<li>打包生产环境: npm build</li>
</ul>
<h4 id="启动webpack"><a href="#启动webpack" class="headerlink" title="启动webpack"></a>启动webpack</h4><p>配置webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &apos;/build&apos;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        query: &#123;</span><br><span class="line">            plugins: [&apos;transform-runtime&apos;],</span><br><span class="line">            presets: [&apos;es2015&apos;, &apos;react&apos;, &apos;stage-2&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        loader: &quot;style-loader!css-loader&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置基本完成,可以写react代码了</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>所有的组件都需要在头部引入 import React from ‘react’</li>
<li>导入组件也用上面方法,使用组件是用半闭合标签<app></app></li>
<li>所有组件在最后都需要  export default 到全局<h4 id="类组件Class"><a href="#类组件Class" class="headerlink" title="类组件Class"></a>类组件Class</h4></li>
<li>所有的类组件都有一个render()方法返回jsx<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class App extends react.component &#123;</span><br><span class="line">  render() &#123; // 返回jsx</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;Hello World!&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="函数型组件Functional"><a href="#函数型组件Functional" class="headerlink" title="函数型组件Functional"></a>函数型组件Functional</h4><p>用 const 定义一个函数,用 props 来传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const List = (props) =&gt; &#123;</span><br><span class="line">  return()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>this.setState 回调函数,参数为 previousState<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState((previousState) =&gt; &#123;</span><br><span class="line">  console.log(previousState)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><h4 id="安装必须的依赖"><a href="#安装必须的依赖" class="headerlink" title="安装必须的依赖"></a>安装必须的依赖</h4><ul>
<li><p>首先安装 redux 和 react-redux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux</span><br><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后安装 redux middleware, 在此先安装 redux-logger, 有助于开发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux-logger</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一些常用的中间件,比如redux-thunk and redux-promise</p>
</li>
</ul>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>使用redux构建react应用一般都有一个标准的模板,不同模板形式上有区别,但思想都是一样的,以下按照一种文件结构来构建</p>
<ul>
<li>首先在src中新建一个文件夹redux,然后在其中新建一个文件configureStore.js,添加以下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware, combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import createLogger from &apos;redux-logger&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>createStore 是由redux提供的用来初始化store的函数, applyMiddleware是用来添加我们需要的中间件的.</p>
<p>combineReducers用来把多个reducers 合并为一个单一实体.</p>
<p>createLogger 可以console出每一个action后数据的详细处理过程,方便调试.使用方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const loggerMiddleware = createLogger();</span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(loggerMiddleware)(createStore)</span><br></pre></td></tr></table></figure></p>
<h4 id="模块modules"><a href="#模块modules" class="headerlink" title="模块modules"></a>模块modules</h4><p>在src/redux/ 新建一个文件夹 modules. 这个文件夹中存放所有的reducers, action creators 和 constants.<br>这里使用的 redux 组织结构叫作 ducks, 就是把相关的 reducers, action creators 和 constants 都放在一个单独的文件中,方便修改,只需修改一个文件夹.</p>
<p>在 modules 中新建组件文件,命名是依据容器组件的名字而来, state就是一个js对象,reducer就是js的switch语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const initialState = &#123;&#125;</span><br><span class="line"></span><br><span class="line">export default function reducer(state = initialState, action) &#123;</span><br><span class="line">  switch(action.type) &#123;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="完善Store"><a href="#完善Store" class="headerlink" title="完善Store"></a>完善Store</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/29/react笔记整理/" data-id="cjnl50y2y0009a8vc8jirldrd" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-css布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/css布局/" class="article-date">
  <time datetime="2018-05-18T07:04:22.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/css布局/">css布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h1><h4 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;box&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>一、 使用inline-block+text-align</p>
<ul>
<li><p>原理、用法</p>
<ul>
<li>原理：先将字盒子由块级元素转换成行内块，再使用text-align设置行内块元素居中</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点:</p>
<ul>
<li>优点:兼容性好,可兼容IE6/7/8</li>
<li>缺点:child里的文字也会水平居中,再设置text-align:left还原<br>二、使用table+margin<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：只设置了child，IE8以上都支持</li>
<li>缺点：不支持低版本浏览器，将div换成table<br>三、使用absolute+transform<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform:translateX(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：居中元素不会对其他产生影响</li>
<li>缺点：transform属css3属性，要考虑兼容性，高版本浏览器前要加前缀<br>四、使用flex+margin<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>缺点：不兼容低版本IE<br>五、使用flex+justify-content<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：设置parent即可</li>
<li>缺点：不兼容低版本IE</li>
</ul>
</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><p>一、使用table-cell—+vertical-align<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display:table-cell;</span><br><span class="line">    vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>优缺点：</p>
<ul>
<li>优点：兼容IE8以上<br>二、使用absolute+transform<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform:translateY(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：居中元素不会对其他产生影响</li>
<li>缺点：transform属css3属性，要考虑兼容性，高版本浏览器前要加前缀<br>三、使用flex+align-items<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position:flex;</span><br><span class="line">    align-items:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：只设置parent</li>
<li>缺点：兼容性存在一定问题</li>
</ul>
</li>
</ul>
<h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>一、使用absolute—+transform<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: tranplate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>优缺点：</p>
<ul>
<li>优点：child元素不会对其他元素产生影响</li>
<li>缺点：兼容性存在一定问题<br>二、使用inline-block+text-align+table-cell+vertical-align<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：兼容性好<br>三、使用flex+justify-content+align-items<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">    align-items:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：只设置了parent</li>
<li>缺点：有兼容性问题</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/18/css布局/" data-id="cjnl50y1r0002a8vcmkaxka4e" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue基础知识整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/vue基础知识整理/" class="article-date">
  <time datetime="2018-01-25T03:26:24.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/vue基础知识整理/">vue基础知识整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><ul>
<li>文本插值</li>
<li>v-html=”html”,HTMl输出</li>
<li>v-bind —-HTML属性插值. <ul>
<li>eg:<button v-bind:disabled="someDynamicCondition">按钮</button></li>
</ul>
</li>
<li>JavaScript表达式—直接在mustache,属性插值里面使用各种表达式(加减乘除,三元运算,方法调用等)</li>
<li>过滤器(有点类似shell命令中的管道,可以定义过滤器来对原始值进行变化)</li>
<li>指令—v-bind,v-on系列(dom事件的监听),v-for,v-model等</li>
</ul>
<h6 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if/v-show"></a>v-if/v-show</h6><p>使用v-if将会删除dom结构,使用v-show是给元素添加display:none属性</p>
<h6 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) of list&quot; :key=&quot;index&quot;&gt;&#123;itwm&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item of list&quot; :key=&quot;item&quot;&gt;&#123;itwm&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p><em>使用v-for循环数组的时候,如果只传一个参数,则循环的数据,key值不可以相同,否则会报错,传两个参数则可以解决</em> </p>
<h4 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h4><p>实际上是viewmodel(数据+函数),都是通过构造函数Vue创建的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    var data = &#123; a: 1 &#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: data, </span><br><span class="line">  created: function () &#123;</span><br><span class="line">    // `this` 指向 vm 实例</span><br><span class="line">    console.log(&apos;a is: &apos; + this.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.$data === data // -&gt; true</span><br><span class="line">vm.$el === document.getElementById(&apos;example&apos;) // -&gt; true</span><br><span class="line">// $watch 是一个实例方法</span><br><span class="line">vm.$watch(&apos;a&apos;, function (newVal, oldVal) &#123;</span><br><span class="line">  // 这个回调会在 `vm.a` 改变的时候触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h5><ul>
<li>created</li>
<li>mounted</li>
<li>updated</li>
<li>destoryed<br><em>所有方法都被call时,this都指向所在的vue实例</em><br>生命周期图如下图所示<br><img src="../../imgs/vue生命周期.png" alt="vue生命周期图"></li>
</ul>
<h4 id="计算属性和监听器"><a href="#计算属性和监听器" class="headerlink" title="计算属性和监听器"></a>计算属性和监听器</h4><h5 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h5><p>其实就是一个需要计算的getter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 一个 computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>和使用method的区别在于,计算属性根据他的依赖被缓存,即如果message没有被修改,下次get不会进行重复计算,而method则每次调用都会重新计算.这也意味着如Date.now()这样返回的计算属性会永远得不到更新.</p>
<h5 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h5><p>默认情况下,计算属性只有一个getter,我们也可以给它加上setter:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   computed: &#123;</span><br><span class="line">      fullName: &#123;</span><br><span class="line">        // getter</span><br><span class="line">        get: function () &#123;</span><br><span class="line">          return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        // setter</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">          var names = newValue.split(&apos; &apos;)</span><br><span class="line">          this.firstName = names[0]</span><br><span class="line">          this.lastName = names[names.length - 1]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br><span class="line">如此,当调用vm.fullName=&quot;Mark&quot;时,firstName和lastName都会被更新</span><br></pre></td></tr></table></figure></p>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>vue的watch也可以用来做类似的事<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>对比一下计算属性版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>看上去简单了很多,那要watcher干啥呢<br>主要应用场景是异步或耗时操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script&gt;</span><br><span class="line">var watchExampleVM = new Vue(&#123;</span><br><span class="line">  el: &apos;#watch-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: &apos;&apos;,</span><br><span class="line">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // 只要 question 改变，这个函数就会执行</span><br><span class="line">    question: function (newQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.getAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // _.debounce is a function provided by lodash to limit how</span><br><span class="line">    // often a particularly expensive operation can be run.</span><br><span class="line">    // In this case, we want to limit how often we access</span><br><span class="line">    // yesno.wtf/api, waiting until the user has completely</span><br><span class="line">    // finished typing before making the ajax request. To learn</span><br><span class="line">    // more about the _.debounce function (and its cousin</span><br><span class="line">    // _.throttle), visit: Lodash Documentation</span><br><span class="line">    getAnswer: _.debounce(</span><br><span class="line">      function () &#123;</span><br><span class="line">        var vm = this</span><br><span class="line">        if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class="line">          vm.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        vm.answer = &apos;Thinking...&apos;</span><br><span class="line">        axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class="line">          .then(function (response) &#123;</span><br><span class="line">            vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(function (error) &#123;</span><br><span class="line">            vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      // 等待用户停止输入后的时间（毫秒）</span><br><span class="line">      500</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>如此,使用watch可以进行异步操作,限制操作间隔,并设置中间状态直到获得真正的答案.<br>除了使用watch option,也可以用vm.$watch</p>
<h4 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h4><p>除了数据绑定,常见的还有style,class的绑定</p>
<h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><p>可以传递一个对象给v-bind:class来动态切换classes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot; </span><br><span class="line">    v-bind:class=&quot;&#123;active:isActive,&apos;text-danger&apos;:hasError&#125;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>对应的active和text-danger则通过data传递过来<br>也可以通过data把class传递过来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data:&#123;</span><br><span class="line">    classObject:&#123;</span><br><span class="line">        active:true,</span><br><span class="line">        &apos;text-danger&apos;:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="vue中安装依赖文件"><a href="#vue中安装依赖文件" class="headerlink" title="vue中安装依赖文件"></a>vue中安装依赖文件</h4><ul>
<li><p>vue-cli webpack全局引入jquery</p>
<ul>
<li><p>首先在package.json里加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies:&#123;</span><br><span class="line"> &quot;jquery&quot; : &quot;^2.2.3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在webpack.base.conf.js里加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&quot;webpack&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在module.exports的最后加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line"> new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;),</span><br><span class="line"> new webpack.ProvidePlugin(&#123;</span><br><span class="line">     jQuery: &quot;jquery&quot;,</span><br><span class="line">     $: &quot;jquery&quot;</span><br><span class="line"> &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后一定要重新 run dev</p>
</li>
<li><p>在main.js 引入就ok了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import $ from &apos;jquery&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装: cnpm/npm install jquery</p>
</li>
</ul>
</li>
<li><p>vue中的$http服务  </p>
<ul>
<li>需要引入一个叫vue-resource.js的文件:cnpm/npm install vue-resource</li>
<li>然后在main.js中配置import VueResource from ‘vue-resource’;</li>
<li>然后用Vue.use(VueResource) 方法启用插件</li>
</ul>
</li>
</ul>
<h4 id="在-vue文件中引入第三方非NPM模块"><a href="#在-vue文件中引入第三方非NPM模块" class="headerlink" title="在.vue文件中引入第三方非NPM模块"></a>在.vue文件中引入第三方非NPM模块</h4><ul>
<li>在 webpack.base.conf.js 中添加externals<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  &apos;zepto&apos;: &apos;Zepto&apos;,</span><br><span class="line">  &apos;wx&apos;: &apos;jWeixin&apos;,</span><br><span class="line">  &apos;swiper&apos;: &apos;Swiper&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>externals 中 swiper 是键，对应的值一定的是插件 swiper.js 所定义的变量 Swiper :</em></p>
<h4 id="webpack打包vue生成的文件-在dist中访问时资源文件报404"><a href="#webpack打包vue生成的文件-在dist中访问时资源文件报404" class="headerlink" title="webpack打包vue生成的文件,在dist中访问时资源文件报404"></a>webpack打包vue生成的文件,在dist中访问时资源文件报404</h4><p>使用vue-cli构建的vue项目，webpack的配置文件是分散在很多地方的，而我们需要修改的是build/webpack.base.conf.js，修改两处的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  // 在开头引入webpack，后面的plugins那里需要</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">// resolve</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">   // 其他代码...</span><br><span class="line">   resolve: &#123;</span><br><span class="line">      extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;],</span><br><span class="line">      fallback: [path.join(__dirname, &apos;../node_modules&apos;)],</span><br><span class="line">      alias: &#123;</span><br><span class="line">          &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),</span><br><span class="line">          &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),</span><br><span class="line">          &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;),</span><br><span class="line"></span><br><span class="line">          // webpack 使用 jQuery，如果是自行下载的</span><br><span class="line">          // &apos;jquery&apos;: path.resolve(__dirname, &apos;../src/assets/libs/jquery/jquery.min&apos;),</span><br><span class="line">          // 如果使用NPM安装的jQuery</span><br><span class="line">          &apos;jquery&apos;: &apos;jquery&apos; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   // 增加一个plugins</span><br><span class="line">   plugins: [</span><br><span class="line">      new webpack.ProvidePlugin(&#123;</span><br><span class="line">          $: &quot;jquery&quot;,</span><br><span class="line">          jQuery: &quot;jquery&quot;</span><br><span class="line">      &#125;)</span><br><span class="line">   ],</span><br><span class="line"></span><br><span class="line">   // 其他代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先修改config目录下的index.js文件<ul>
<li>将其中build的配置项assetsPublicPath进行修改，改为</li>
<li><img src="../../imgs/修改公共路径.png" alt=""></li>
</ul>
</li>
<li>此时html中的js、css、img引入均没有问题，但是css中的background-image还是报404 <ul>
<li>此时的问题原因是，使用了相对地址后，在css进行引入的图片路径，其相对的是css文件的路径</li>
<li>此时的修改方法是，修改build文件夹中的utils.js文件，修改如下这一行</li>
<li><img src="../../imgs/修改图片路径.jpg" alt=""><br>这样css中的背景图也OK了，如果在css中引入字体也可以用这样的方式修复404问题。</li>
</ul>
</li>
<li>要引入Bootstrap，我们在vue的入口js文件src/main.js开头加入<br>// 使用Bootstrap<br>import ‘./assets/libs/bootstrap/css/bootstrap.min.css’<br>import ‘./assets/libs/bootstrap/js/bootstrap.min’</li>
<li>使用toastr组件，只需要在需要的地方import进来，或者全局引入css在需要的地方引用js，然后直接使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用toastr</span><br><span class="line">import &apos;assets/libs/toastr/toastr.min.css&apos;</span><br><span class="line">import toastr from &apos;assets/libs/toastr/toastr.min&apos;</span><br><span class="line"></span><br><span class="line">toastr.success(&apos;Hello&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="给后台传参数时报错"><a href="#给后台传参数时报错" class="headerlink" title="给后台传参数时报错"></a>给后台传参数时报错</h4><p>如果Web服务器无法处理编码为applicationjson的请求，你可以启用emulateJSON选项。启用该选项后，请求会以application/x-www-form-urlencoded作为MIME type，就像普通的HTML表单一样。<br>说白了post在进行数据请求时；需要填写第三个参数{emulateJSON:true}，否则后台是无法获取你传递的参数的<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.$http.post(&quot;http://192.168.0.192:8085/user/phonePCMessageValidation&quot;,&#123;</span><br><span class="line">  &apos;phoneNumber&apos;:&apos;1563*****05&apos;&#125;,&#123;emulateJSON:true&#125;).then(</span><br><span class="line">  function (res) &#123;            </span><br><span class="line">                        // 处理成功的结果</span><br><span class="line">        console.log(res.body)</span><br><span class="line">    </span><br><span class="line">  &#125;,function (err) &#123;</span><br><span class="line">  // 处理失败的结果</span><br><span class="line">  console.log(err)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/vue基础知识整理/" data-id="cjnl50y1r0003a8vcvezlcdtg" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/Git命令/" class="article-date">
  <time datetime="2018-01-25T03:11:26.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/Git命令/">Git命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h3><h4 id="1-新建代码库"><a href="#1-新建代码库" class="headerlink" title="1.新建代码库"></a>1.新建代码库</h4><ul>
<li>在当前目录下新建一个git代码库:git init</li>
<li>新建一个目录,将其初始化为git代码库:git init [projectName]</li>
<li>下载一个项目:git clone [url]</li>
</ul>
<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h4><p>Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<ul>
<li>显示当前的Git配置:git config –list</li>
<li>编辑Git配置文件:git config -e [–global]</li>
<li>设置提交代码时的用户信息:<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”  </li>
</ul>
</li>
</ul>
<h4 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3.增加/删除文件"></a>3.增加/删除文件</h4><ul>
<li>添加指定文件到暂存区:git add [file1] [file2] …</li>
<li>添加指定目录到暂存区,包括子目录:git add [dir]</li>
<li>添加当前目录的所有文件到暂存区:git add .</li>
<li>添加每个变化前,都会要求确认,对同一个文件的多处变化,可以实现分次提交:<ul>
<li>git add -p</li>
</ul>
</li>
<li>删除工作区文件,并且将这次删除放入暂存区:git rm [file1] [file2] …</li>
<li>停止追踪指定文件,但该文件会保留在工作区:git rm –cached [file]</li>
<li>改名文件,并且将这个改名放在暂存区:git mv [file-original-name] [file-renamed]</li>
</ul>
<h4 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4.代码提交"></a>4.代码提交</h4><ul>
<li>提交暂存区到仓库区:git commit -m [message]</li>
<li>提交暂存区的指定文件到仓库区:git commit [file1] … -m [message]</li>
<li>提交工作区自上次commit之后的变化，直接到仓库区:git commit -a</li>
<li>提交时显示所有diff信息:git commit -v</li>
<li>使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息:git commit –amend -m [message]</li>
<li>重做上一次commit，并包括指定文件的新变化:git commit –amend [file1] [file2] …</li>
</ul>
<h4 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h4><ul>
<li>列出本地所有分支:git branch</li>
<li>列出所有远程分支:git branch -r</li>
<li>列出所有本地分支和远程分支:git branch  -a</li>
<li>新建一个分支,但依然停留在当前分支: git branch [branch-name]</li>
<li>新建一个分支,并切换到该分支:git checkout -b [branch]</li>
<li>新建一个分支,指向指定commit:git branch [branch] [commit]</li>
<li>新建一个分支,与指定的远程分支建立追踪关系:git branch –track [branch] [remote-branch]</li>
<li><ul>
<li>创建空的分支:(执行命令之前记得先提交你当前分支的修改,否则会被强制删干净,)<ul>
<li>git symbolic-ref HEAD refs/heads/[name]</li>
<li>rm .git/index</li>
<li>git clean -fdx</li>
</ul>
</li>
</ul>
</li>
<li>切换到指定分支,并更新工作区:git checkout [branch] [remote-branch]</li>
<li>切换到上一个分支:git checkout</li>
<li>建立追踪关系,在现有分支与指定远程分支之间:git branch –set-upstream [branch] [remote-branch]</li>
<li>合并指定分支到当前分支:git merge [branch]</li>
<li>选择一个commit,合并进当前分支:git cherry-pick [commit]</li>
<li>删除分支:git branch -d [branch-name]</li>
<li>删除远程分支:<ul>
<li>git push origin –delete [branch-name]</li>
<li>git branch -dr [remote/branch]   </li>
</ul>
</li>
</ul>
<h4 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h4><ul>
<li>列出所有tag:git tag</li>
<li>新建一个tag在当前commit:git tag [tag]</li>
<li>新建一个tag在指定commit:git tag [tag] [commit]</li>
<li>删除本地tag:git tag -d [tag]</li>
<li>删除远程tag:git push origin :refs/tags/[tagName]</li>
<li>查看tag信息:git show [tag]</li>
<li>提交所有tag:git push [remote] –tags</li>
<li>提交指定tag:git push [remote] [tag]</li>
<li>新建一个分支,指向某个tag:git checkout -b [branch] [tag]</li>
</ul>
<h4 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7.查看信息"></a>7.查看信息</h4><ul>
<li>显示有变更的文件:git status</li>
<li>显示当前分支的版本历史:git log</li>
<li>显示commit历史,以及每次commit发生变更的文件:git log –stat</li>
<li>搜索提交历史,根据关键词:git log -s [keywo]</li>
<li>显示某个commit之后的所有变动,每个commit占据一行:git log [tag] HEAD –pretty=format:%s</li>
<li>显示某个commit之后的所有变动,其”提交说明”必须符合搜索条件:git log [tag] HEAD –grep feature </li>
<li>显示过去5次提交:git log -5 –pretty –online</li>
<li>显示所有提交过的用户:git shortlog -sn</li>
</ul>
<h4 id="分支操作相关命令"><a href="#分支操作相关命令" class="headerlink" title="分支操作相关命令"></a>分支操作相关命令</h4><ul>
<li>查看本地分支:git branch</li>
<li>查看远程分支:git branch -r</li>
<li>创建本地分支:git branch [name] *注意新分支创建后不会自动切换为当前分支</li>
<li>切换分支:git checkout [name]</li>
<li>创建新分支并立即切换到新分支:git checkout -b[name]</li>
<li>删除分支:git branch -d [name] *-d选项只能删除已经参与了合并的分支，对于未合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</li>
<li>合并分支:git merge [name] *将名称为[name]的分支与当前分支合并</li>
<li>创建远程分支(本地分支push到远程):git push origin [name]</li>
<li>删除远程分支 git push origin:heads/[name]或gitpush origin:[name]</li>
</ul>
<h4 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h4><ul>
<li>查看版本:git tag</li>
<li>创建版本:git tag [name]</li>
<li>删除版本:git tag -d [name]</li>
<li>查看远程版本:git tag -r</li>
<li>创建远程版本(本地版本push到远程):git push origin [name]</li>
<li>删除远程版本:git push origin :refs/tags/[name]</li>
<li>合并远程仓库的tag到本地:git pull origin –tags</li>
<li>上传本地tag到远程仓库:git push origin –tags</li>
<li>创建带注释的tag:git tag -a [name] -m ‘yourMessage’</li>
</ul>
<h4 id="本地代码上传到git仓库-项目迁移"><a href="#本地代码上传到git仓库-项目迁移" class="headerlink" title="本地代码上传到git仓库(项目迁移)"></a>本地代码上传到git仓库(项目迁移)</h4><ul>
<li>初始化:git init</li>
<li>添加文件到版本库中:git add .</li>
<li>提交文件到仓库:git commit -m ‘’</li>
<li>关联到远程库:git remote add origin 远程仓库地址</li>
<li>获取远程仓库的内容推送到远程(如果远程库不为空必须做这一步,否则后面提交会失败):git pull –rebase origin  master</li>
<li>推送本地库代码:git push -u origin master</li>
<li>状态查询:git status</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/Git命令/" data-id="cjnl50y210005a8vcq3m3d6np" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-工作笔记整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/工作笔记整理/" class="article-date">
  <time datetime="2018-01-25T01:52:37.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/工作笔记整理/">工作笔记整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="一、判断系统是否是移动端并跳转至相应页面"><a href="#一、判断系统是否是移动端并跳转至相应页面" class="headerlink" title="一、判断系统是否是移动端并跳转至相应页面"></a>一、判断系统是否是移动端并跳转至相应页面</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">////判断是否移动端，如果是则跳转到指定的URL地址</span><br><span class="line">function browserRedirect(url) &#123;</span><br><span class="line">    //只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值</span><br><span class="line">    var sUserAgent = navigator.userAgent.toLowerCase();</span><br><span class="line">    var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;;</span><br><span class="line">    var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;;</span><br><span class="line">    var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;;</span><br><span class="line">    var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;;</span><br><span class="line">    var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;;</span><br><span class="line">    var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;;</span><br><span class="line">    var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;;</span><br><span class="line">    if (bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123;</span><br><span class="line">        window.location.replace(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">browserRedirect(url);//可跳转html和jsp页面</span><br></pre></td></tr></table></figure></p>
<h4 id="二、获取系统时间并返回指定的日期格式"><a href="#二、获取系统时间并返回指定的日期格式" class="headerlink" title="二、获取系统时间并返回指定的日期格式"></a>二、获取系统时间并返回指定的日期格式</h4><ul>
<li><p>获取系统当天时间,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getDay(date)&#123;</span><br><span class="line">    date=new Date();</span><br><span class="line">    var y = date.getFullYear();</span><br><span class="line">    var m = date.getMonth()+1;</span><br><span class="line">    var d = date.getDate();</span><br><span class="line">    m = m &lt; 10 ? (&apos;0&apos; + m) : m;</span><br><span class="line">    d = d &lt; 10 ? (&apos;0&apos; + d) : d;</span><br><span class="line">    return y +&apos;/&apos;+ m +&apos;/&apos;+ d;</span><br><span class="line">    // return y +&apos;-&apos; + m + &apos;-&apos; + d;</span><br><span class="line">&#125;</span><br><span class="line">var date=getDay(Date());</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当天日期后面几天的日期,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var date1=new Date();</span><br><span class="line">var date2=new Date(date1);</span><br><span class="line">date2.setDate(date1.getDate()+n);//n为要加的天数</span><br><span class="line">var date=getDay(date2);</span><br><span class="line">console.log(&apos;date&apos;+date);//date:2017/12/14+n</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送短信验证码倒计时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let time = 60</span><br><span class="line">function settime(obj) &#123;</span><br><span class="line">    if (time === 0) &#123;</span><br><span class="line">        obj.attr(&apos;disabled&apos;, false)</span><br><span class="line">        obj.val(&apos;获取验证码&apos;)</span><br><span class="line">        time = 60</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    obj.attr(&apos;disabled&apos;, true)</span><br><span class="line">    obj.val(`重新发送( $&#123;time&#125; s)`)</span><br><span class="line">    console.log(time)</span><br><span class="line">    time--</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        settime(obj)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">settime(dom)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="获取url地址栏参数"><a href="#获取url地址栏参数" class="headerlink" title="获取url地址栏参数"></a>获取url地址栏参数</h4><ul>
<li><p>jquery扩展方法代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function($)&#123;</span><br><span class="line">    $.getUrlParam=function(name)&#123;</span><br><span class="line">        var reg=new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">        var r=window.location.search.substr(1).match(reg);</span><br><span class="line">        if(r != null)</span><br><span class="line">        return unescape(r[2]);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line">//使用时调用该方法即可</span><br><span class="line">//eg:</span><br><span class="line">var name=$.getUrlParam(&apos;name&apos;);</span><br><span class="line">var age=$.getUrlParam(&apos;age&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function GetQueryString(name) &#123;</span><br><span class="line">    const reg = new RegExp(`(^|&amp;)$&#123;name&#125;=([^&amp;]*)(&amp;|$)`)</span><br><span class="line">    const r = window.location.search.substr(1).match(reg)</span><br><span class="line">    if (r != null) return unescape(r[2])</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="移动端页面调出键盘后输入框被遮挡的解决办法"><a href="#移动端页面调出键盘后输入框被遮挡的解决办法" class="headerlink" title="移动端页面调出键盘后输入框被遮挡的解决办法"></a>移动端页面调出键盘后输入框被遮挡的解决办法</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;input&apos;).bind(&apos;click&apos;,function(e)&#123;</span><br><span class="line">    var $this = $(this);</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    // setTimeout(function()&#123;</span><br><span class="line">    //     $(window).scrollTop($this.offset().top - 10);</span><br><span class="line">    // &#125;,200);</span><br><span class="line">    setTimeout(function()&#123;   </span><br><span class="line">         document.body.scrollTop = document.body.scrollHeight;  </span><br><span class="line">    &#125;,300); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="短信链接调起本地APP或下载APP"><a href="#短信链接调起本地APP或下载APP" class="headerlink" title="短信链接调起本地APP或下载APP"></a>短信链接调起本地APP或下载APP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 判断手机系统</span><br><span class="line">var ua = navigator.userAgent.toLowerCase();  </span><br><span class="line">var t;</span><br><span class="line">var config = &#123;  </span><br><span class="line">  scheme_IOS: &apos;XHJD://open&apos;,  </span><br><span class="line">  scheme_Adr: &apos;xhjd://app/open&apos;,  </span><br><span class="line">  adr_download_url: &apos;http://android.myapp.com/myapp/detail.htm?apkName=com.allyoubank.xinhuagolden&apos;,  </span><br><span class="line">  ios_download_url: &apos;https://itunes.apple.com/cn/app/id1267250937?mt=8&apos;, </span><br><span class="line">  timeout: 2000</span><br><span class="line">&#125;;</span><br><span class="line">function openApp() &#123;</span><br><span class="line">    var startTime = Date.now();  </span><br><span class="line">    var ifr = document.createElement(&apos;iframe&apos;);  </span><br><span class="line">    ifr.src = ua.indexOf(&apos;os&apos;) &gt; 0 ? config.scheme_IOS : config.scheme_Adr;  </span><br><span class="line">    ifr.style.display = &apos;none&apos;;  </span><br><span class="line">    document.body.appendChild(ifr);  </span><br><span class="line">    window.location.href = config.scheme_IOS </span><br><span class="line">    t = setTimeout(function() &#123;  </span><br><span class="line">        var endTime = Date.now();  </span><br><span class="line">        if (!startTime || endTime - startTime &lt; config.timeout + 200) &#123; </span><br><span class="line">            console.log(&apos;您还未下载“新华金典理财”&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, config.timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改a标签href属性"><a href="#修改a标签href属性" class="headerlink" title="修改a标签href属性"></a>修改a标签href属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var href=$(&apos;a&apos;).attr(&apos;href&apos;);</span><br><span class="line">href=$(&apos;a&apos;).attr(&apos;href&apos;,href);</span><br></pre></td></tr></table></figure>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="一、解决谷歌浏览器输入框飘黄"><a href="#一、解决谷歌浏览器输入框飘黄" class="headerlink" title="一、解决谷歌浏览器输入框飘黄"></a>一、解决谷歌浏览器输入框飘黄</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    input:-webkit-autofill &#123; </span><br><span class="line">    -webkit-box-shadow: 0 0 0px 1000px color inset; </span><br><span class="line">    /*color值自定义*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/工作笔记整理/" data-id="cjnl50y210004a8vc674735cp" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NodeJs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/NodeJs/" class="article-date">
  <time datetime="2018-01-25T01:48:50.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/NodeJs/">NodeJs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Node-js应用的组成部分"><a href="#Node-js应用的组成部分" class="headerlink" title="Node.js应用的组成部分"></a>Node.js应用的组成部分</h4><ul>
<li>引入required模块:使用require指令来载入Node.js模块</li>
<li>创建服务器:服务器可以监听客户端的请求,类似于Apache、Nginx等HTTP服务器</li>
<li>接收请求与响应请求:服务器很容易创建,客户端可以使用浏览器或终端发送HTTP请求,服务器接收请求后返回响应数据</li>
</ul>
<h4 id="Node-js创建第一个应用"><a href="#Node-js创建第一个应用" class="headerlink" title="Node.js创建第一个应用"></a>Node.js创建第一个应用</h4><h5 id="步骤一、引入required模块"><a href="#步骤一、引入required模块" class="headerlink" title="步骤一、引入required模块"></a>步骤一、引入required模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var http=require(&quot;http&quot;);</span><br></pre></td></tr></table></figure>
<h5 id="步骤二、创建服务器"><a href="#步骤二、创建服务器" class="headerlink" title="步骤二、创建服务器"></a>步骤二、创建服务器</h5><p>接下来使用 http.createServer()方法创建服务器，并使用listen方法绑定8888端口。函数通过request，response参数来接收和相应数据。<br>示例如下：<br>再项目根目录下创建一个叫server.js文件，包含以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    var http=require(&quot;http&quot;);</span><br><span class="line">    http.createServer(function(request,response)&#123;</span><br><span class="line"></span><br><span class="line">    //发送http头部</span><br><span class="line">    //HTTP状态值：200：OK</span><br><span class="line">    //内容类型：text/plain</span><br><span class="line">    response.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;);</span><br><span class="line"></span><br><span class="line">    //发送响应数据&quot;Hello World&quot;</span><br><span class="line">    response.end(&apos;Hello World\n&apos;);</span><br><span class="line">&#125;).listen(8888);</span><br><span class="line">//终端打印如下信息</span><br><span class="line">console.log(&apos;Server running at http://127.0.0.1:8888/&apos;);</span><br></pre></td></tr></table></figure></p>
<p>分析上面代码:<br>1.第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。<br>2.接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</p>
<h4 id="使用npm安装模块"><a href="#使用npm安装模块" class="headerlink" title="使用npm安装模块"></a>使用npm安装模块</h4><p>npm安装Node.js模块语法格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;</span><br><span class="line">Node.js常用的模块express</span><br><span class="line">npm install express</span><br></pre></td></tr></table></figure></p>
<p>安装好之后,express包就放在工程目录下的node_modules目录中,因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var express=require(&apos;express&apos;);</span><br></pre></td></tr></table></figure></p>
<h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><p>npm uninstall express<br>卸载后可使用命令行来查看是否卸载掉<br>npm ls</p>
<h4 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h4><p>npm update express</p>
<h4 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h4><p>npm search express</p>
<h4 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h4><p>创建模块,package.json是必不可少的,使用npm生成package.json文件,生成的文件中包含了基本的结果<br>npm init<br>接下来使用命令在npm资源库中注册用户(使用邮箱注册):<br>npm adduser<br>Username:XXX<br>Password:<br>Email:</p>
<h4 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h4><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。<br>Node自带了交互式解释器,可以执行以下任务:</p>
<ul>
<li>读取 –读取用户输入.解析输入了JavaScript数据结构并存储在内存中</li>
<li>执行 –执行输入的数据结构</li>
<li>打印 –输出结果</li>
<li>循环 –循环操作以上步骤直到用户两次按下Ctrl+c按钮退出<br>Node的交互式解释器可以很好的调试JavaScript代码</li>
</ul>
<p>启动node:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>在&gt;后面输入简单的表达式,并按下回车就可以计算结果</p>
<ul>
<li>简单的表达式运算</li>
<li>使用变量<ul>
<li>可以将数据存储在变量中,并在需要的时候使用它</li>
<li>变量声明使用var关键字,如果没有var关键字会直接打印出来</li>
<li>使用var关键字的变量可以使用console.log()来输出变量.</li>
</ul>
</li>
<li>多行表达式<br>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    $ node</span><br><span class="line">    &gt; var x = 0</span><br><span class="line">    undefined</span><br><span class="line">    &gt; do &#123;</span><br><span class="line">    ... x++;</span><br><span class="line">    ... console.log(&quot;x: &quot; + x);</span><br><span class="line">    ... &#125; while ( x &lt; 5 );</span><br><span class="line">    x: 1</span><br><span class="line">    x: 2</span><br><span class="line">    x: 3</span><br><span class="line">    x: 4</span><br><span class="line">    x: 5</span><br><span class="line">    undefined</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>… 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
<ul>
<li>下划线(<em>)变量<br>*可以使用下划线</em>获取表达式的远算结果:*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var x = 10</span><br><span class="line">undefined</span><br><span class="line">&gt; var y = 20</span><br><span class="line">undefined</span><br><span class="line">&gt; x + y</span><br><span class="line">30</span><br><span class="line">&gt; var sum = _</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(sum)</span><br><span class="line">30</span><br><span class="line">undefined</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="REPL命令"><a href="#REPL命令" class="headerlink" title="REPL命令"></a>REPL命令</h4><ul>
<li>Ctrl+c –退出当前终端</li>
<li>ctrl + c 按下两次 - 退出 Node REPL。</li>
<li>ctrl + d - 退出 Node REPL.</li>
<li>向上/向下 键 - 查看输入的历史命令</li>
<li>tab 键 - 列出当前命令</li>
<li>.help - 列出使用命令</li>
<li>.break - 退出多行表达式</li>
<li>.clear - 退出多行表达式</li>
<li>.save filename - 保存当前的 Node REPL 会话到指定文件</li>
<li>.load filename - 载入当前 Node REPL 会话的文件内容</li>
</ul>
<h4 id="停止-REPL"><a href="#停止-REPL" class="headerlink" title="停止 REPL"></a>停止 REPL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt;</span><br><span class="line">(^C again to quit)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/NodeJs/" data-id="cjnl50y2y0008a8vcb6umnnyv" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/23/面向对象总结/">面向对象总结</a>
          </li>
        
          <li>
            <a href="/2018/10/18/原生js整理/">原生js整理</a>
          </li>
        
          <li>
            <a href="/2018/10/12/html代码实现一些符号/">html代码实现一些符号</a>
          </li>
        
          <li>
            <a href="/2018/10/10/面试题整理-vue/">面试题整理-vue</a>
          </li>
        
          <li>
            <a href="/2018/05/29/react笔记整理/">react笔记整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Wang Yonge<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>