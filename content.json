{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Wang Yonge","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"css布局","slug":"css布局","date":"2018-03-21T06:33:00.000Z","updated":"2018-03-21T09:57:26.464Z","comments":true,"path":"2018/03/21/css布局/","link":"","permalink":"http://yoursite.com/2018/03/21/css布局/","excerpt":"","text":"居中布局水平布局123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;box&lt;/div&gt;&lt;/div&gt; 一、 使用inline-block+text-align 原理、用法 原理：先将字盒子由块级元素转换成行内块，再使用text-align设置行内块元素居中 用法：123456.parent &#123; text-align:center;&#125;.child &#123; display: inline-block;&#125; 优缺点: 优点:兼容性好,可兼容IE6/7/8 缺点:child里的文字也会水平居中,再设置text-align:left还原二、使用table+margin1234.child &#123; display: table; margin: 0 auto;&#125; 优缺点： 优点：只设置了child，IE8以上都支持 缺点：不支持低版本浏览器，将div换成table三、使用absolute+transform12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; left: 50%; transform:translateX(-50%);&#125; 优缺点： 优点：居中元素不会对其他产生影响 缺点：transform属css3属性，要考虑兼容性，高版本浏览器前要加前缀四、使用flex+margin123456.parent &#123; display:flex;&#125;.child &#123; margin: 0 auto;&#125; 优缺点： 缺点：不兼容低版本IE五、使用flex+justify-content1234.parent &#123; display:flex; justify-content:center;&#125; 优缺点： 优点：设置parent即可 缺点：不兼容低版本IE 垂直居中一、使用table-cell—+vertical-align1234.parent &#123; display:table-cell; vertical-align:middle;&#125; 优缺点： 优点：兼容IE8以上二、使用absolute+transform12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; top: 50%; transform:translateY(-50%);&#125; 优缺点： 优点：居中元素不会对其他产生影响 缺点：transform属css3属性，要考虑兼容性，高版本浏览器前要加前缀三、使用flex+align-items1234.parent &#123; position:flex; align-items:center;&#125; 优缺点： 优点：只设置parent 缺点：兼容性存在一定问题 水平垂直居中一、使用absolute—+transform123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; top: 50%; transform: tranplate(-50%, -50%);&#125; 优缺点： 优点：child元素不会对其他元素产生影响 缺点：兼容性存在一定问题二、使用inline-block+text-align+table-cell+vertical-align12345678.parent &#123; text-align: center; display: table-cell; vertical-align: middle;&#125;.child &#123; display: inline-block;&#125; 优缺点： 优点：兼容性好三、使用flex+justify-content+align-items12345.parent &#123; display:flex; justify-content:center; align-items:center;&#125; 优缺点： 优点：只设置了parent 缺点：有兼容性问题","categories":[],"tags":[]},{"title":"vue基础知识整理","slug":"vue基础知识整理","date":"2018-01-25T03:26:24.000Z","updated":"2018-01-25T04:02:43.796Z","comments":true,"path":"2018/01/25/vue基础知识整理/","link":"","permalink":"http://yoursite.com/2018/01/25/vue基础知识整理/","excerpt":"","text":"模板语法 文本插值 v-html=”html”,HTMl输出 v-bind —-HTML属性插值. eg:按钮 JavaScript表达式—直接在mustache,属性插值里面使用各种表达式(加减乘除,三元运算,方法调用等) 过滤器(有点类似shell命令中的管道,可以定义过滤器来对原始值进行变化) 指令—v-bind,v-on系列(dom事件的监听),v-for,v-model等 vue实例实际上是viewmodel(数据+函数),都是通过构造函数Vue创建的123456789101112131415 var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: data, created: function () &#123; // `this` 指向 vm 实例 console.log(&apos;a is: &apos; + this.a) &#125;&#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById(&apos;example&apos;) // -&gt; true// $watch 是一个实例方法vm.$watch(&apos;a&apos;, function (newVal, oldVal) &#123; // 这个回调会在 `vm.a` 改变的时候触发&#125;) vue的生命周期 created mounted updated destoryed所有方法都被call时,this都指向所在的vue实例生命周期图如下图所示 计算属性和监听器计算属性其实就是一个需要计算的getter123456789101112131415161718&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 一个 computed getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;)&lt;/div&gt; 和使用method的区别在于,计算属性根据他的依赖被缓存,即如果message没有被修改,下次get不会进行重复计算,而method则每次调用都会重新计算.这也意味着如Date.now()这样返回的计算属性会永远得不到更新. Setter默认情况下,计算属性只有一个getter,我们也可以给它加上setter:123456789101112131415 computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 如此,当调用vm.fullName=&quot;Mark&quot;时,firstName和lastName都会被更新 监听器vue的watch也可以用来做类似的事1234567891011121314151617 &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 对比一下计算属性版本123456789101112 var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;) 看上去简单了很多,那要watcher干啥呢主要应用场景是异步或耗时操作:1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;script&gt;var watchExampleVM = new Vue(&#123; el: &apos;#watch-example&apos;, data: &#123; question: &apos;&apos;, answer: &apos;I cannot give you an answer until you ask a question!&apos; &#125;, watch: &#123; // 只要 question 改变，这个函数就会执行 question: function (newQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce is a function provided by lodash to limit how // often a particularly expensive operation can be run. // In this case, we want to limit how often we access // yesno.wtf/api, waiting until the user has completely // finished typing before making the ajax request. To learn // more about the _.debounce function (and its cousin // _.throttle), visit: Lodash Documentation getAnswer: _.debounce( function () &#123; var vm = this if (this.question.indexOf(&apos;?&apos;) === -1) &#123; vm.answer = &apos;Questions usually contain a question mark. ;-)&apos; return &#125; vm.answer = &apos;Thinking...&apos; axios.get(&apos;https://yesno.wtf/api&apos;) .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = &apos;Error! Could not reach the API. &apos; + error &#125;) &#125;, // 等待用户停止输入后的时间（毫秒） 500 ) &#125;&#125;)&lt;/script&gt; 如此,使用watch可以进行异步操作,限制操作间隔,并设置中间状态直到获得真正的答案.除了使用watch option,也可以用vm.$watch class和style绑定除了数据绑定,常见的还有style,class的绑定 对象语法可以传递一个对象给v-bind:class来动态切换classes:123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123;active:isActive,&apos;text-danger&apos;:hasError&#125;&quot;&gt;&lt;/div&gt; 对应的active和text-danger则通过data传递过来也可以通过data把class传递过来1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data:&#123; classObject:&#123; active:true, &apos;text-danger&apos;:false &#125;&#125; vue中安装依赖文件 vue-cli webpack全局引入jquery 首先在package.json里加入 123dependencies:&#123; &quot;jquery&quot; : &quot;^2.2.3&quot;&#125; 在webpack.base.conf.js里加入 1var webpack = require(&quot;webpack&quot;) 在module.exports的最后加入 1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;)] 然后一定要重新 run dev 在main.js 引入就ok了 1import $ from &apos;jquery&apos; 安装: cnpm/npm install jquery vue中的$http服务 需要引入一个叫vue-resource.js的文件:cnpm/npm install vue-resource 然后在main.js中配置import VueResource from ‘vue-resource’; 然后用Vue.use(VueResource) 方法启用插件 在.vue文件中引入第三方非NPM模块 在 webpack.base.conf.js 中添加externals12345externals: &#123; &apos;zepto&apos;: &apos;Zepto&apos;, &apos;wx&apos;: &apos;jWeixin&apos;, &apos;swiper&apos;: &apos;Swiper&apos;&#125; externals 中 swiper 是键，对应的值一定的是插件 swiper.js 所定义的变量 Swiper : webpack打包vue生成的文件,在dist中访问时资源文件报404使用vue-cli构建的vue项目，webpack的配置文件是分散在很多地方的，而我们需要修改的是build/webpack.base.conf.js，修改两处的代码12345678910111213141516171819202122232425262728293031 // 在开头引入webpack，后面的plugins那里需要var webpack = require(&apos;webpack&apos;)// resolvemodule.exports = &#123; // 其他代码... resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], fallback: [path.join(__dirname, &apos;../node_modules&apos;)], alias: &#123; &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;), &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;), &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;), // webpack 使用 jQuery，如果是自行下载的 // &apos;jquery&apos;: path.resolve(__dirname, &apos;../src/assets/libs/jquery/jquery.min&apos;), // 如果使用NPM安装的jQuery &apos;jquery&apos;: &apos;jquery&apos; &#125; &#125;, // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], // 其他代码...&#125; 首先修改config目录下的index.js文件 将其中build的配置项assetsPublicPath进行修改，改为 此时html中的js、css、img引入均没有问题，但是css中的background-image还是报404 此时的问题原因是，使用了相对地址后，在css进行引入的图片路径，其相对的是css文件的路径 此时的修改方法是，修改build文件夹中的utils.js文件，修改如下这一行 这样css中的背景图也OK了，如果在css中引入字体也可以用这样的方式修复404问题。 要引入Bootstrap，我们在vue的入口js文件src/main.js开头加入// 使用Bootstrapimport ‘./assets/libs/bootstrap/css/bootstrap.min.css’import ‘./assets/libs/bootstrap/js/bootstrap.min’ 使用toastr组件，只需要在需要的地方import进来，或者全局引入css在需要的地方引用js，然后直接使用12345// 使用toastrimport &apos;assets/libs/toastr/toastr.min.css&apos;import toastr from &apos;assets/libs/toastr/toastr.min&apos;toastr.success(&apos;Hello&apos;) 给后台传参数时报错如果Web服务器无法处理编码为applicationjson的请求，你可以启用emulateJSON选项。启用该选项后，请求会以application/x-www-form-urlencoded作为MIME type，就像普通的HTML表单一样。说白了post在进行数据请求时；需要填写第三个参数{emulateJSON:true}，否则后台是无法获取你传递的参数的代码如下:1234567891011this.$http.post(&quot;http://192.168.0.192:8085/user/phonePCMessageValidation&quot;,&#123; &apos;phoneNumber&apos;:&apos;1563*****05&apos;&#125;,&#123;emulateJSON:true&#125;).then( function (res) &#123; // 处理成功的结果 console.log(res.body) &#125;,function (err) &#123; // 处理失败的结果 console.log(err) &#125;);&#125;","categories":[],"tags":[]},{"title":"Git命令","slug":"Git命令","date":"2018-01-25T03:11:26.000Z","updated":"2018-01-25T11:16:26.755Z","comments":true,"path":"2018/01/25/Git命令/","link":"","permalink":"http://yoursite.com/2018/01/25/Git命令/","excerpt":"","text":"常用操作命令1.新建代码库 在当前目录下新建一个git代码库:git init 新建一个目录,将其初始化为git代码库:git init [projectName] 下载一个项目:git clone [url] 2.配置Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置:git config –list 编辑Git配置文件:git config -e [–global] 设置提交代码时的用户信息: git config [–global] user.name “[name]” git config [–global] user.email “[email address]” 3.增加/删除文件 添加指定文件到暂存区:git add [file1] [file2] … 添加指定目录到暂存区,包括子目录:git add [dir] 添加当前目录的所有文件到暂存区:git add . 添加每个变化前,都会要求确认,对同一个文件的多处变化,可以实现分次提交: git add -p 删除工作区文件,并且将这次删除放入暂存区:git rm [file1] [file2] … 停止追踪指定文件,但该文件会保留在工作区:git rm –cached [file] 改名文件,并且将这个改名放在暂存区:git mv [file-original-name] [file-renamed] 4.代码提交 提交暂存区到仓库区:git commit -m [message] 提交暂存区的指定文件到仓库区:git commit [file1] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区:git commit -a 提交时显示所有diff信息:git commit -v 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息:git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化:git commit –amend [file1] [file2] … 5.分支 列出本地所有分支:git branch 列出所有远程分支:git branch -r 列出所有本地分支和远程分支:git branch -a 新建一个分支,但依然停留在当前分支: git branch [branch-name] 新建一个分支,并切换到该分支:git checkout -b [branch] 新建一个分支,指向指定commit:git branch [branch] [commit] 新建一个分支,与指定的远程分支建立追踪关系:git branch –track [branch] [remote-branch] 创建空的分支:(执行命令之前记得先提交你当前分支的修改,否则会被强制删干净,) git symbolic-ref HEAD refs/heads/[name] rm .git/index git clean -fdx 切换到指定分支,并更新工作区:git checkout [branch] [remote-branch] 切换到上一个分支:git checkout 建立追踪关系,在现有分支与指定远程分支之间:git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支:git merge [branch] 选择一个commit,合并进当前分支:git cherry-pick [commit] 删除分支:git branch -d [branch-name] 删除远程分支: git push origin –delete [branch-name] git branch -dr [remote/branch] 6.标签 列出所有tag:git tag 新建一个tag在当前commit:git tag [tag] 新建一个tag在指定commit:git tag [tag] [commit] 删除本地tag:git tag -d [tag] 删除远程tag:git push origin :refs/tags/[tagName] 查看tag信息:git show [tag] 提交所有tag:git push [remote] –tags 提交指定tag:git push [remote] [tag] 新建一个分支,指向某个tag:git checkout -b [branch] [tag] 7.查看信息 显示有变更的文件:git status 显示当前分支的版本历史:git log 显示commit历史,以及每次commit发生变更的文件:git log –stat 搜索提交历史,根据关键词:git log -s [keywo] 显示某个commit之后的所有变动,每个commit占据一行:git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动,其”提交说明”必须符合搜索条件:git log [tag] HEAD –grep feature 显示过去5次提交:git log -5 –pretty –online 显示所有提交过的用户:git shortlog -sn 分支操作相关命令 查看本地分支:git branch 查看远程分支:git branch -r 创建本地分支:git branch [name] *注意新分支创建后不会自动切换为当前分支 切换分支:git checkout [name] 创建新分支并立即切换到新分支:git checkout -b[name] 删除分支:git branch -d [name] *-d选项只能删除已经参与了合并的分支，对于未合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支:git merge [name] *将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程):git push origin [name] 删除远程分支 git push origin:heads/[name]或gitpush origin:[name] 版本(tag)操作相关命令 查看版本:git tag 创建版本:git tag [name] 删除版本:git tag -d [name] 查看远程版本:git tag -r 创建远程版本(本地版本push到远程):git push origin [name] 删除远程版本:git push origin :refs/tags/[name] 合并远程仓库的tag到本地:git pull origin –tags 上传本地tag到远程仓库:git push origin –tags 创建带注释的tag:git tag -a [name] -m ‘yourMessage’ 本地代码上传到git仓库(项目迁移) 初始化:git init 添加文件到版本库中:git add . 提交文件到仓库:git commit -m ‘’ 关联到远程库:git remote add origin 远程仓库地址 获取远程仓库的内容推送到远程(如果远程库不为空必须做这一步,否则后面提交会失败):git pull –rebase origin master 推送本地库代码:git push -u origin master 状态查询:git status","categories":[],"tags":[]},{"title":"工作笔记整理","slug":"工作笔记整理","date":"2018-01-25T01:52:37.000Z","updated":"2018-05-18T01:43:28.239Z","comments":true,"path":"2018/01/25/工作笔记整理/","link":"","permalink":"http://yoursite.com/2018/01/25/工作笔记整理/","excerpt":"","text":"JS一、判断系统是否是移动端并跳转至相应页面代码如下:12345678910111213141516////判断是否移动端，如果是则跳转到指定的URL地址function browserRedirect(url) &#123; //只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值 var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; if (bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123; window.location.replace(url); &#125;&#125;browserRedirect(url);//可跳转html和jsp页面 二、获取系统时间并返回指定的日期格式 获取系统当天时间,代码如下： 1234567891011function getDay(date)&#123; date=new Date(); var y = date.getFullYear(); var m = date.getMonth()+1; var d = date.getDate(); m = m &lt; 10 ? (&apos;0&apos; + m) : m; d = d &lt; 10 ? (&apos;0&apos; + d) : d; return y +&apos;/&apos;+ m +&apos;/&apos;+ d; // return y +&apos;-&apos; + m + &apos;-&apos; + d;&#125;var date=getDay(Date()); 获取当天日期后面几天的日期,代码如下: 12345var date1=new Date();var date2=new Date(date1);date2.setDate(date1.getDate()+n);//n为要加的天数var date=getDay(date2);console.log(&apos;date&apos;+date);//date:2017/12/14+n 发送短信验证码倒计时 123456789101112131415161718let time = 60function settime(obj) &#123; if (time === 0) &#123; obj.attr(&apos;disabled&apos;, false) obj.val(&apos;获取验证码&apos;) time = 60 return &#125; obj.attr(&apos;disabled&apos;, true) obj.val(`重新发送( $&#123;time&#125; s)`) console.log(time) time-- setTimeout(() =&gt; &#123; settime(obj) &#125;, 1000)&#125;// 使用方法settime(dom) jquery扩展方法获取url地址栏参数代码如下:12345678910111213(function($)&#123; $.getUrlParam=function(name)&#123; var reg=new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r=window.location.search.substr(1).match(reg); if(r != null) return unescape(r[2]); return null; &#125;&#125;)(jQuery);//使用时调用该方法即可//eg:var name=$.getUrlParam(&apos;name&apos;);var age=$.getUrlParam(&apos;age&apos;); 移动端页面调出键盘后输入框被遮挡的解决办法代码如下:12345678910$(&apos;input&apos;).bind(&apos;click&apos;,function(e)&#123; var $this = $(this); e.preventDefault(); // setTimeout(function()&#123; // $(window).scrollTop($this.offset().top - 10); // &#125;,200); setTimeout(function()&#123; document.body.scrollTop = document.body.scrollHeight; &#125;,300); &#125;) 修改a标签href属性12var href=$(&apos;a&apos;).attr(&apos;href&apos;);href=$(&apos;a&apos;).attr(&apos;href&apos;,href); CSS一、解决谷歌浏览器输入框飘黄代码如下:1234 input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px color inset; /*color值自定义*/&#125;","categories":[],"tags":[]},{"title":"NodeJs","slug":"NodeJs","date":"2018-01-25T01:48:50.000Z","updated":"2018-01-25T01:49:20.642Z","comments":true,"path":"2018/01/25/NodeJs/","link":"","permalink":"http://yoursite.com/2018/01/25/NodeJs/","excerpt":"","text":"Node.js应用的组成部分 引入required模块:使用require指令来载入Node.js模块 创建服务器:服务器可以监听客户端的请求,类似于Apache、Nginx等HTTP服务器 接收请求与响应请求:服务器很容易创建,客户端可以使用浏览器或终端发送HTTP请求,服务器接收请求后返回响应数据 Node.js创建第一个应用步骤一、引入required模块1var http=require(&quot;http&quot;); 步骤二、创建服务器接下来使用 http.createServer()方法创建服务器，并使用listen方法绑定8888端口。函数通过request，response参数来接收和相应数据。示例如下：再项目根目录下创建一个叫server.js文件，包含以下代码12345678910111213 var http=require(&quot;http&quot;); http.createServer(function(request,response)&#123; //发送http头部 //HTTP状态值：200：OK //内容类型：text/plain response.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;); //发送响应数据&quot;Hello World&quot; response.end(&apos;Hello World\\n&apos;);&#125;).listen(8888);//终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;); 分析上面代码:1.第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。2.接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。 使用npm安装模块npm安装Node.js模块语法格式如下:123npm install &lt;Module Name&gt;Node.js常用的模块expressnpm install express 安装好之后,express包就放在工程目录下的node_modules目录中,因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。1var express=require(&apos;express&apos;); 卸载模块npm uninstall express卸载后可使用命令行来查看是否卸载掉npm ls 更新模块npm update express 搜索模块npm search express 创建模块创建模块,package.json是必不可少的,使用npm生成package.json文件,生成的文件中包含了基本的结果npm init接下来使用命令在npm资源库中注册用户(使用邮箱注册):npm adduserUsername:XXXPassword:Email: Node.js REPL(交互式解释器)Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。Node自带了交互式解释器,可以执行以下任务: 读取 –读取用户输入.解析输入了JavaScript数据结构并存储在内存中 执行 –执行输入的数据结构 打印 –输出结果 循环 –循环操作以上步骤直到用户两次按下Ctrl+c按钮退出Node的交互式解释器可以很好的调试JavaScript代码 启动node:12$ node&gt; 在&gt;后面输入简单的表达式,并按下回车就可以计算结果 简单的表达式运算 使用变量 可以将数据存储在变量中,并在需要的时候使用它 变量声明使用var关键字,如果没有var关键字会直接打印出来 使用var关键字的变量可以使用console.log()来输出变量. 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：1234567891011121314 $ node &gt; var x = 0 undefined &gt; do &#123; ... x++; ... console.log(&quot;x: &quot; + x); ... &#125; while ( x &lt; 5 ); x: 1 x: 2 x: 3 x: 4 x: 5 undefined&gt; … 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线()变量*可以使用下划线获取表达式的远算结果:*12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL命令 Ctrl+c –退出当前终端 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容 停止 REPL1234$ node&gt;(^C again to quit)&gt;","categories":[],"tags":[]},{"title":"hexo基本命令","slug":"hexo基本命令","date":"2018-01-24T06:27:46.000Z","updated":"2018-01-25T04:59:19.650Z","comments":true,"path":"2018/01/24/hexo基本命令/","link":"","permalink":"http://yoursite.com/2018/01/24/hexo基本命令/","excerpt":"","text":"日常更新 本地新建文件名:hexo new “博客名” 生成文档: hexo g -d 运行本地服务器:hexo s -g ,浏览器中http://localhost:4000 同步到github:hexo d -g 卸载hexo 3.0.0版本执行:npm uninstall hexo-cli-g, 旧版本执行:npm uninstall hexo -g 安装旧版本hexo 先卸载当前版本,以2.8.3为例,执行:npm uninstall hexo@2.8.3 -g,再初始化并安装依赖和插件 安装hexo npm install hexo-cli -g hexo init blog cd blog npm install hexo server 域名绑定如果你不想使用yourusername.github.io，也可以绑定自己的域名，将域名的CNAME指向yourusername.github.io，然后在github下面新建一个CNAME文件，里面写上你的域名，然后就能通过域名直接访问到yourusername.github.io了。 安装Next主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装插件123456//feed插件npm install hexo-generator-feed --save//站点地图npm install hexo-generator-sitemap --save//百度站点地图npm install hexo-generator-baidu-sitemap --save SEO优化1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;","categories":[],"tags":[]}]}