{"meta":{"title":"Hexo","subtitle":"前端小白学习中","description":null,"author":"Wang Yonge","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"原生js整理","slug":"原生js整理","date":"2018-10-18T01:35:23.000Z","updated":"2018-10-19T08:47:37.808Z","comments":true,"path":"2018/10/18/原生js整理/","link":"","permalink":"http://yoursite.com/2018/10/18/原生js整理/","excerpt":"","text":"js事件机制 点击屏幕上一个按钮,事件是如何传播的?捕获, 冒泡 js bind 实现机制1234567891011// 代码来自书籍《JavaScript模式》if (typeof Function.prototype.bind === &apos;undefined&apos;) &#123; Function.prototype.bind = function (thisArgs) &#123; var fn = this, slice = Array.prototype.slice, args = slice.call(arguments, 1) return function () &#123; return fn.apply(thisArgs, args.concat(slice.call(arguments))) &#125; &#125;&#125; 实现vue中的on, emit, off, once, 手写代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 参照vue源码实现var EventEmiter = function () &#123; this._events = &#123;&#125;&#125;EventEmiter.prototpye.on = function (event, cb) &#123; if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.on(event[i], cb) &#125; &#125; else &#123; (this._events[event] || (this._events[event] = [])).push(cb) &#125; return this&#125;EventEmiter.prototype.once = function (event, cb) &#123; function on () &#123; this.off(event, cb) cb.apply(this, arguments) &#125; on.fn = cb this.on(event, on) return this&#125;EventEmiter.prototype.off = function (event, cb) &#123; if (!arguments.length) &#123; this._events = Object.create(null) return this &#125; if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; this.off(event[i], cb) &#125; return this &#125; if (!cb) &#123; this._events[event] = null return this &#125; if (cb) &#123; let cbs = this.length while(i--) &#123; if (cb === cbs[i] || cb === cb[i].fn) &#123; cbs.splice(i, l) break; &#125; &#125; return this &#125;&#125;EventAEmiter.prototype.emit = function (event) &#123; let cbs = this._event[event] let args = Array.prototype.slice.call(arguments, 1) if (cbs) &#123; for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; cbs[i].apply(this.args) &#125; &#125;&#125; Object.prototype.toString.call()方法使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下： Object.prototype.toString.call(value)12345678910111213141516171819202122232425262728293031323334353637// 1.判断基本类型Object.prototype.toString.call(null) // [object Null]Object.prototype.toString.call(undefined) // [object Undefined]Object.prototpye.toString.call(&apos;abc&apos;) // [object String]Object.prototype.toString.call(123) // [object Number]Object.prototype.toString.call(true) // [object Boolean] // 2.判断原生引用类型// 函数类型function fn () &#123; console.log(&apos;test&apos;)&#125;Object.prototype..toString.call(fn) // [object Function]// 日期类型var date = new Date()Onject.prototype.toString.call(date) // [object Date]// 数组类型var arr = [1, 2, 3]Object.prototype.toString.call(arr) // [object Array]// 正则表达式var reg = /[hbc]at/giObject.prototype.toString.call(reg) // [object RegExp]// 自定义类型function Person (name, age) &#123; this.name = name this.age = age&#125;var people = new Person(&apos;Lily&apos;, 20)Object.prototype.toString.call(people) // [object Object]// 很明显这种方法不能准确判断people是Person的实例,而只能用instanceof 操作符来进行判断console.log(people instanceof Person) // true// 3. 判断原生Json对象var isNativeJson = window.JSON &amp;&amp; Object.prototype.toString.call(JSON)console.log(isNativeJson)// 输出结果为 [object JSON],说明JSON是原生的,否则不是;// 注意: Object.prototype.toString()本身是允许被修改的,而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的","categories":[],"tags":[]},{"title":"html代码实现一些符号","slug":"html代码实现一些符号","date":"2018-10-12T01:15:36.000Z","updated":"2018-10-12T01:35:47.483Z","comments":true,"path":"2018/10/12/html代码实现一些符号/","link":"","permalink":"http://yoursite.com/2018/10/12/html代码实现一些符号/","excerpt":"","text":"在网站开发中常常需要用到一些特殊字符,如商标注册,版权等,以下表格列举常用的符号用HTML代码表示 符号 代码 解释 &lt; &amp;lt 小于号 &gt; &amp;gt 大于号 “” &amp;quot 引号 &amp; &amp;amp 可用与现实其他特殊字符 ® &amp;reg 已注册 © &amp;copy 版权 ™ &amp;trade 商标 &amp;ensp 半方大的空白 &amp;emsp 全方大的空白 &amp;nbsp 不断行的空白","categories":[],"tags":[]},{"title":"面试题整理-vue","slug":"面试题整理-vue","date":"2018-10-10T06:20:33.000Z","updated":"2018-10-12T07:13:15.410Z","comments":true,"path":"2018/10/10/面试题整理-vue/","link":"","permalink":"http://yoursite.com/2018/10/10/面试题整理-vue/","excerpt":"","text":"什么是MVVMMVVM是Model-View-ViewModeld的缩写.MVVM是一种设计思想. Model层代表数据模型,也可以在Model中定义数据修改和操作的业务逻辑, View层代表UI组件,负责将数据模型转化成UI展现出来, ViewModel是同步View和Model的对象.在MVVM架构下,View和Model之间并没有直接的联系,而是通过ViewModel进行交互,Model和ViewModel之间的交互是双向的,因此View的数据变化会同步到Model中,而Model的数据变化也会立即反应到View上.ViewModel通过数据绑定把View层和Model层连接起来,而View和Model之间的同步工作是自动的,无需人为干涉.因此开发者只需关注业务逻辑,不需要手动操作DOM,不需要关注数据状态的同步问题,复杂的数据状态维护完全由MVVM来统一管理. MVVM和MVC的区别 相同点: 都是一种设计思想 不同点: MVC中的controller演变成MVVM中的ViewModel, MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低,加载速度变慢,影响用户体验;以及当Model频繁发生改变,开发者需要主动更新到View vue 的优点是什么 低耦合: 视图(View)可以独立于Model变化和修改,一个ViewModel可以绑定到不同的View上,当View变化的时候,Model可以不变,当Model变化的时候View也可以不变. 可重用性: 可以把一些视图逻辑放在一个VIewModel中,让很多View重用这段视图逻辑. 独立开发: 开发人员可以专注于业务逻辑和数据的开发(VIewModel), 设计人员可以专注于页面设计,使用Express Blend可以很容易设计界面并生成xml代码. 可测试: 界面素来是比较难于测试的,而现在测试可以针对ViewNode了来写. vue生命周期vue实例从创建到销毁的过程,就是生命周期.八个阶段: 创建前后,载入前/后,更新前/后,销毁前/后 创建前/后: 在beforeCreate阶段,vue实例的挂载元素el和数据对象data都为undefined,还未初始化.在created阶段,vue实例的数据对象有data了,el还没有. 载入前/后: 在beforeMount阶段,vue实例的$el 和data都初始化了,但还是挂载之前为虚拟的dom节点,data.message还未替换.在mounted阶段,vue实例挂载完成,data.message成功渲染. 更新前/后: 当data变化时,会触发beforeUpdate和updated方法. 销毁前/后: 在执行destroy方法后,对data的改变不会再触发周期函数,说明此时vue实例已经解除了事件监听以及和dom的绑定,但是dom结构依然存在. 生命周期的作用: 生命周期中有多个事件钩子,让我们在控制整个vue实例的过程时更容易形成良好的逻辑. 第一次页面加载会触发哪几个钩子: beforeCreate, created, beforeMount, mounted DOM渲染完成的周期在哪个: mounted 每个周期具体适合哪些场景: beforeCreate: 可以在此处加个loading事件,加载实例时触发, created: 初始化完成时的事件写在这里,若在这结束loading事件,异步请求也可以在这里调用 mounted: 挂载元素,获取DOM节点 updated: 如果 对数据统一处理,在这里写上相应函数 beforeDestroy: 可以做一个停止事件的确认框 nextTick: 更新数据后立即操作dom arguments是一个伪数组,没有便利借口,不能遍历 双向数据绑定的原理 vue.js是采用数据劫持结合发布者-订阅者模式的方式,通过Object.defineProperty()来劫持各个属性的setter,getter,在数据变动时发布消息给订阅者,触发相应的监听回调.具体步骤 第一步: 需要observe的数据对象进行遍历递归,包括子属性对象的属性,都加上setter和getter这样的话,给这个对象的某个值赋值,就会触发setter 第二步: compile解析模板指令,将模板中的变量替换成数据,然后初始化熏染页面视图,并将每个指令对应的节点绑定更新函数,添加数据的订阅者,一旦数据有变动,收到通知,更新视图. 第三步: watcher订阅者是observer和compile之间通信的桥梁,主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 带属性变动dep.notice()通知时,能调用自身的update()方法,并触发compile中绑定的回调,则功成身退. 第四步: MVVM作为数据绑定的入口,整合observer, compile和watcher三者通过observer来监听自己的model数据变化,通过compile来解释编译模板指令,最终利用watcher打起observer和compile之间通信桥梁,达到数据变化-&gt;视图更新; 视图交互变化(input) -&gt; 数据model变更的双向绑定效果 组件之间的传值父组件与子组件之间的传值12345678910111213141516171819202122232425262728293031// 父组件通过标签上面定义传值&lt;template&gt; &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; // 引入子组件 import Main from &apos;./main&apos; export default &#123; name: &apos;parent&apos;, data() &#123; return &#123; data: &apos;向子组件传递数据&apos; &#125; &#125;, // 初始化组件 components: &#123; Main &#125; &#125;&lt;/script&gt;// 子组件通过props方法接收数据&lt;template&gt; &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;sun&apos;, props: [&apos;data&apos;] &#125;&lt;/script&gt; 子组件向父组件传递数据1234567891011121314151617181920212223242526272829303132333435363738394041// 子组件通过$emit方法传递参数&lt;template&gt; &lt;div @click=&quot;sendMsgToParent&quot;&gt;向父组件传值&lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入子组件 export default &#123; props: [&apos;message&apos;], methods: &#123; sendMsgToParent() &#123; this.$emit(&apos;listenToChildEvent&apos;, &apos;this message is from child&apos;) &#125; &#125; &#125;&lt;/script&gt;// 在父组件中监听自定义事件并添加一个响应该事件的处理方式&lt;template&gt; &lt;div&gt; &lt;Main v-bind:message=&quot;parentMsg&quot; v-on:listenToChildEvent=&quot;showMsgFromChild&quot;&gt;&lt;/Main&gt; &lt;/div&gt;&lt;/tempalte&gt;&lt;script&gt; import Main from &apos;./main&apos; export default &#123; name: &apos;parent&apos;, data() &#123; return &#123; parentMsg: &apos;hello, Child&apos; &#125; &#125;, components: &#123; Main &#125;, methods: &#123; showMsgFromChild(data) &#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt; 嵌套路由怎么定义在vue-router的参数中使用children配置,就可以实现路由嵌套12345678910111213141516171819// 引入两个子组件import home from &apos;./home&apos;import game from &apos;./game&apos;const routes = [ &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125;, &#123; path: &apos;/home&apos;, component: home, children: [ &#123; path: &apos;/home/game&apos;, component: game &#125; ] &#125;] 怎么定义vue-router的动态路由?怎么获取传过来的动态参数? 在router目录下的index.js文件中,对path属性加上/:id 使用router对象的params.id vue-router有哪几种导航钩子三种 全局导航钩子: router.beforeEach(to, from, next), 作用: 跳转前进行判断拦截 组件内的钩子 单独路由独享组件 scss是什么?在vue-cli中的安装使用步骤是?有哪几大特性? css的预编译 使用步骤: 用npm下三个loader(sass-loader, css-loader, node-sass)在build目录找到webpack.base.config.js,在extends属性中加一个拓展.scss 在上述文件中配置一个module属性 在组件的style标签上加上lang属性,例如: lang=”scss” 特性: 可以用变量, 例如:$变量名称=值 可以用混合器 可以嵌套 sass和less的区别 都是动态的样式语言,是css预处理器,css上的一种抽象层.是一种特殊的语法/语言编译成css 区别: 变量符不一样,less是@,sass是$ sass支持条件语句,可以使用if{}else{},for循环等等,而less不支持 sass是基于ruby的,是在服务端处理的,而less需要引入less.js来处理less代码输出css到浏览器 axios是什么?怎么使用?描述使用它实现登录功能的流程请求后台资源的模块npm install axios安装好,然后发送的是跨域,需在配置文件中config/index.js进行设置.后台如果是Tp5则定义一个资源路由.js使用import导入,然后.get或.post.返回在.then函数中,失败在.catch函数中 axios + tp5进阶中,调用axios.post(‘api/user’)是进行的什么操作?axios.put(‘api/user/8’)呢? 跨域 添加用户操作 更新操作 active-class是哪个组件的属性vue-router模块的router-link组件 mint-ui是什么?怎么使用?说出至少三个组件的使用方法 基于vue的前端组件库 npm安装,import样式和js 全局引入: vue.use(mintUI) 单个组件引入: import {组件} from ‘mint-ui’ 组件例举: Toast(‘获取成功’) mint-header mint-swiper 封装vue组件的过程封装组件可以解决传统项目效率低,难维护,复用性等问题.使用vue.extend方法创建一个组件,然后使用vue.component方法注册组件.子组件需要数据,可以在props中接收定义,而子组件修改好数据后,想把数据传递给父组件,可以采用emit方法. vue.js对template编译过程首先转换成AST树,再得到render函数返回VNode(vue的虚拟DOM节点)步骤: 通过compile编译器把template变异成AST语法树(abstract syntax tree),compile是createCompiler的返回值,createCompiler是用以创建编译器的.另外compile还负责合并option. AST会经过generate(将AST语法树转化成render function字符串的过程)得到render函数,render的返回值是VNode,VNode是vue的虚拟DOM节点,里面有(标签名,子节点,文本等等) vue的历史记录: history记录中向前或者后退多少步 v-show和v-if指令的异同点 实现手段 v-show指令是通过修改元素的display属性为显示或隐藏 v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 编译过程 v-if切换有一个局部编译/卸载的过程,切换过程中合适地销毁和重建内部的事件监听和子组件v-show只是简单的css切换 编译条件 v-if是惰性的,如果初始条件为假,则什么也不做;只有在条件第一次变成真的时候才会开始局部编译(编译被缓存?编译被缓存后,然后再切换的时候进行局部卸载); v-show是在任何条件下(首次条件是否为真)都被编译,然后被缓存,而且DOM元素保留 性能消耗 v-if有更高的切换消耗 v-show有更高的初始渲染消耗 使用场景 v-if适合运营条件不大可能改变 v-show适合频繁切换 如何让css只在当前组件中起作用在当前组件的style标签中添加scoped属性 &lt;keep-alive&gt;&lt;/keep-alive&gt;的作用使用该标签包裹动态组件时,会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染eg: 用户在列表页查看详情时会频繁执行:详情-&gt;返回列表-&gt;详情-&gt;返回列表,在此,列表和详情都是一个频率很高的页面,就可以使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存列表,这样用户在返回列表时就可以快速从缓存中渲染,而不是重新渲染. vue-cli项目目录中src目录中每个文件夹和文件的作用 assets: 放置静态资源 components: 放置组件 router: 定义路由相关的配置 view: 视图 app.vue: 应用主组件 main.js: 入口文件","categories":[],"tags":[]},{"title":"react笔记整理","slug":"react笔记整理","date":"2018-05-29T06:30:48.000Z","updated":"2018-06-05T11:55:06.621Z","comments":true,"path":"2018/05/29/react笔记整理/","link":"","permalink":"http://yoursite.com/2018/05/29/react笔记整理/","excerpt":"","text":"React 基础知识项目搭建初始化 化生成package.json文件: npm init 安装依赖 安装react: npm install react –save 安装react-dom: npm install react-dom –save 如果使用react-native 则安装react-native 安装webpack: npm install webpack –save-dev npm install webpack-dev-server 支持热加载 安装babel,将ES6 转化为ES5: npm install babel-core –save-dev 安装babel其他工具 npm install babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-preset-react babel-preset-stage-2 babel-runtime babel-polyfill –save-dev 配置项目运行命令在package.json中修改scripts1234&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --hot --inline --colors --content-base ./build&quot;, &quot;build&quot;: &quot;webpack --progress --colors&quot;&#125; 运行项目: npm start 打包生产环境: npm build 启动webpack配置webpack.config.js12345678910111213141516171819202122var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./src/index.js&apos;, output: &#123; path: __dirname + &apos;/build&apos;, filename: &quot;bundle.js&quot; &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &apos;babel-loader&apos;, query: &#123; plugins: [&apos;transform-runtime&apos;], presets: [&apos;es2015&apos;, &apos;react&apos;, &apos;stage-2&apos;] &#125; &#125;, &#123; test: /\\.css$/, loader: &quot;style-loader!css-loader&quot; &#125;] &#125;&#125; 配置基本完成,可以写react代码了 组件 所有的组件都需要在头部引入 import React from ‘react’ 导入组件也用上面方法,使用组件是用半闭合标签 所有组件在最后都需要 export default 到全局类组件Class 所有的类组件都有一个render()方法返回jsx1234567class App extends react.component &#123; render() &#123; // 返回jsx return ( &lt;div&gt;Hello World!&lt;/div&gt; ) &#125;&#125; 函数型组件Functional用 const 定义一个函数,用 props 来传参123const List = (props) =&gt; &#123; return()&#125; this.setState 回调函数,参数为 previousState123this.setState((previousState) =&gt; &#123; console.log(previousState)&#125;) redux安装必须的依赖 首先安装 redux 和 react-redux 12npm install --save reduxnpm install --save react-redux 然后安装 redux middleware, 在此先安装 redux-logger, 有助于开发 1npm install --save redux-logger 还有一些常用的中间件,比如redux-thunk and redux-promise 构建使用redux构建react应用一般都有一个标准的模板,不同模板形式上有区别,但思想都是一样的,以下按照一种文件结构来构建 首先在src中新建一个文件夹redux,然后在其中新建一个文件configureStore.js,添加以下代码12import &#123; createStore, applyMiddleware, combineReducers &#125; from &apos;redux&apos;;import createLogger from &apos;redux-logger&apos;; createStore 是由redux提供的用来初始化store的函数, applyMiddleware是用来添加我们需要的中间件的. combineReducers用来把多个reducers 合并为一个单一实体. createLogger 可以console出每一个action后数据的详细处理过程,方便调试.使用方法如下:12const loggerMiddleware = createLogger();const createStoreWithMiddleware = applyMiddleware(loggerMiddleware)(createStore) 模块modules在src/redux/ 新建一个文件夹 modules. 这个文件夹中存放所有的reducers, action creators 和 constants.这里使用的 redux 组织结构叫作 ducks, 就是把相关的 reducers, action creators 和 constants 都放在一个单独的文件中,方便修改,只需修改一个文件夹. 在 modules 中新建组件文件,命名是依据容器组件的名字而来, state就是一个js对象,reducer就是js的switch语句:12345678const initialState = &#123;&#125;export default function reducer(state = initialState, action) &#123; switch(action.type) &#123; default: return state; &#125;&#125; 完善Store","categories":[],"tags":[]},{"title":"css布局","slug":"css布局","date":"2018-05-18T07:04:22.000Z","updated":"2018-05-18T07:05:02.791Z","comments":true,"path":"2018/05/18/css布局/","link":"","permalink":"http://yoursite.com/2018/05/18/css布局/","excerpt":"","text":"居中布局水平布局123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;box&lt;/div&gt;&lt;/div&gt; 一、 使用inline-block+text-align 原理、用法 原理：先将字盒子由块级元素转换成行内块，再使用text-align设置行内块元素居中 用法：123456.parent &#123; text-align:center;&#125;.child &#123; display: inline-block;&#125; 优缺点: 优点:兼容性好,可兼容IE6/7/8 缺点:child里的文字也会水平居中,再设置text-align:left还原二、使用table+margin1234.child &#123; display: table; margin: 0 auto;&#125; 优缺点： 优点：只设置了child，IE8以上都支持 缺点：不支持低版本浏览器，将div换成table三、使用absolute+transform12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; left: 50%; transform:translateX(-50%);&#125; 优缺点： 优点：居中元素不会对其他产生影响 缺点：transform属css3属性，要考虑兼容性，高版本浏览器前要加前缀四、使用flex+margin123456.parent &#123; display:flex;&#125;.child &#123; margin: 0 auto;&#125; 优缺点： 缺点：不兼容低版本IE五、使用flex+justify-content1234.parent &#123; display:flex; justify-content:center;&#125; 优缺点： 优点：设置parent即可 缺点：不兼容低版本IE 垂直居中一、使用table-cell—+vertical-align1234.parent &#123; display:table-cell; vertical-align:middle;&#125; 优缺点： 优点：兼容IE8以上二、使用absolute+transform12345678.parent &#123; position:relative;&#125;.child &#123; position:absolute; top: 50%; transform:translateY(-50%);&#125; 优缺点： 优点：居中元素不会对其他产生影响 缺点：transform属css3属性，要考虑兼容性，高版本浏览器前要加前缀三、使用flex+align-items1234.parent &#123; position:flex; align-items:center;&#125; 优缺点： 优点：只设置parent 缺点：兼容性存在一定问题 水平垂直居中一、使用absolute—+transform123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; top: 50%; transform: tranplate(-50%, -50%);&#125; 优缺点： 优点：child元素不会对其他元素产生影响 缺点：兼容性存在一定问题二、使用inline-block+text-align+table-cell+vertical-align12345678.parent &#123; text-align: center; display: table-cell; vertical-align: middle;&#125;.child &#123; display: inline-block;&#125; 优缺点： 优点：兼容性好三、使用flex+justify-content+align-items12345.parent &#123; display:flex; justify-content:center; align-items:center;&#125; 优缺点： 优点：只设置了parent 缺点：有兼容性问题","categories":[],"tags":[]},{"title":"vue基础知识整理","slug":"vue基础知识整理","date":"2018-01-25T03:26:24.000Z","updated":"2018-06-28T09:33:16.204Z","comments":true,"path":"2018/01/25/vue基础知识整理/","link":"","permalink":"http://yoursite.com/2018/01/25/vue基础知识整理/","excerpt":"","text":"模板语法 文本插值 v-html=”html”,HTMl输出 v-bind —-HTML属性插值. eg:按钮 JavaScript表达式—直接在mustache,属性插值里面使用各种表达式(加减乘除,三元运算,方法调用等) 过滤器(有点类似shell命令中的管道,可以定义过滤器来对原始值进行变化) 指令—v-bind,v-on系列(dom事件的监听),v-for,v-model等 v-if/v-show使用v-if将会删除dom结构,使用v-show是给元素添加display:none属性 v-for1234567&lt;ul&gt; &lt;li v-for=&quot;(item, index) of list&quot; :key=&quot;index&quot;&gt;&#123;itwm&#125;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li v-for=&quot;item of list&quot; :key=&quot;item&quot;&gt;&#123;itwm&#125;&lt;/li&gt;&lt;/ul&gt; 使用v-for循环数组的时候,如果只传一个参数,则循环的数据,key值不可以相同,否则会报错,传两个参数则可以解决 vue实例实际上是viewmodel(数据+函数),都是通过构造函数Vue创建的123456789101112131415 var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: data, created: function () &#123; // `this` 指向 vm 实例 console.log(&apos;a is: &apos; + this.a) &#125;&#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById(&apos;example&apos;) // -&gt; true// $watch 是一个实例方法vm.$watch(&apos;a&apos;, function (newVal, oldVal) &#123; // 这个回调会在 `vm.a` 改变的时候触发&#125;) vue的生命周期 created mounted updated destoryed所有方法都被call时,this都指向所在的vue实例生命周期图如下图所示 计算属性和监听器计算属性其实就是一个需要计算的getter123456789101112131415161718&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 一个 computed getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;)&lt;/div&gt; 和使用method的区别在于,计算属性根据他的依赖被缓存,即如果message没有被修改,下次get不会进行重复计算,而method则每次调用都会重新计算.这也意味着如Date.now()这样返回的计算属性会永远得不到更新. Setter默认情况下,计算属性只有一个getter,我们也可以给它加上setter:123456789101112131415 computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 如此,当调用vm.fullName=&quot;Mark&quot;时,firstName和lastName都会被更新 监听器vue的watch也可以用来做类似的事1234567891011121314151617 &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 对比一下计算属性版本123456789101112 var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;) 看上去简单了很多,那要watcher干啥呢主要应用场景是异步或耗时操作:1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;script&gt;var watchExampleVM = new Vue(&#123; el: &apos;#watch-example&apos;, data: &#123; question: &apos;&apos;, answer: &apos;I cannot give you an answer until you ask a question!&apos; &#125;, watch: &#123; // 只要 question 改变，这个函数就会执行 question: function (newQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce is a function provided by lodash to limit how // often a particularly expensive operation can be run. // In this case, we want to limit how often we access // yesno.wtf/api, waiting until the user has completely // finished typing before making the ajax request. To learn // more about the _.debounce function (and its cousin // _.throttle), visit: Lodash Documentation getAnswer: _.debounce( function () &#123; var vm = this if (this.question.indexOf(&apos;?&apos;) === -1) &#123; vm.answer = &apos;Questions usually contain a question mark. ;-)&apos; return &#125; vm.answer = &apos;Thinking...&apos; axios.get(&apos;https://yesno.wtf/api&apos;) .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = &apos;Error! Could not reach the API. &apos; + error &#125;) &#125;, // 等待用户停止输入后的时间（毫秒） 500 ) &#125;&#125;)&lt;/script&gt; 如此,使用watch可以进行异步操作,限制操作间隔,并设置中间状态直到获得真正的答案.除了使用watch option,也可以用vm.$watch class和style绑定除了数据绑定,常见的还有style,class的绑定 对象语法可以传递一个对象给v-bind:class来动态切换classes:123&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123;active:isActive,&apos;text-danger&apos;:hasError&#125;&quot;&gt;&lt;/div&gt; 对应的active和text-danger则通过data传递过来也可以通过data把class传递过来1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data:&#123; classObject:&#123; active:true, &apos;text-danger&apos;:false &#125;&#125; vue中安装依赖文件 vue-cli webpack全局引入jquery 首先在package.json里加入 123dependencies:&#123; &quot;jquery&quot; : &quot;^2.2.3&quot;&#125; 在webpack.base.conf.js里加入 1var webpack = require(&quot;webpack&quot;) 在module.exports的最后加入 1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;)] 然后一定要重新 run dev 在main.js 引入就ok了 1import $ from &apos;jquery&apos; 安装: cnpm/npm install jquery vue中的$http服务 需要引入一个叫vue-resource.js的文件:cnpm/npm install vue-resource 然后在main.js中配置import VueResource from ‘vue-resource’; 然后用Vue.use(VueResource) 方法启用插件 在.vue文件中引入第三方非NPM模块 在 webpack.base.conf.js 中添加externals12345externals: &#123; &apos;zepto&apos;: &apos;Zepto&apos;, &apos;wx&apos;: &apos;jWeixin&apos;, &apos;swiper&apos;: &apos;Swiper&apos;&#125; externals 中 swiper 是键，对应的值一定的是插件 swiper.js 所定义的变量 Swiper : webpack打包vue生成的文件,在dist中访问时资源文件报404使用vue-cli构建的vue项目，webpack的配置文件是分散在很多地方的，而我们需要修改的是build/webpack.base.conf.js，修改两处的代码12345678910111213141516171819202122232425262728293031 // 在开头引入webpack，后面的plugins那里需要var webpack = require(&apos;webpack&apos;)// resolvemodule.exports = &#123; // 其他代码... resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], fallback: [path.join(__dirname, &apos;../node_modules&apos;)], alias: &#123; &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;), &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;), &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;), // webpack 使用 jQuery，如果是自行下载的 // &apos;jquery&apos;: path.resolve(__dirname, &apos;../src/assets/libs/jquery/jquery.min&apos;), // 如果使用NPM安装的jQuery &apos;jquery&apos;: &apos;jquery&apos; &#125; &#125;, // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], // 其他代码...&#125; 首先修改config目录下的index.js文件 将其中build的配置项assetsPublicPath进行修改，改为 此时html中的js、css、img引入均没有问题，但是css中的background-image还是报404 此时的问题原因是，使用了相对地址后，在css进行引入的图片路径，其相对的是css文件的路径 此时的修改方法是，修改build文件夹中的utils.js文件，修改如下这一行 这样css中的背景图也OK了，如果在css中引入字体也可以用这样的方式修复404问题。 要引入Bootstrap，我们在vue的入口js文件src/main.js开头加入// 使用Bootstrapimport ‘./assets/libs/bootstrap/css/bootstrap.min.css’import ‘./assets/libs/bootstrap/js/bootstrap.min’ 使用toastr组件，只需要在需要的地方import进来，或者全局引入css在需要的地方引用js，然后直接使用12345// 使用toastrimport &apos;assets/libs/toastr/toastr.min.css&apos;import toastr from &apos;assets/libs/toastr/toastr.min&apos;toastr.success(&apos;Hello&apos;) 给后台传参数时报错如果Web服务器无法处理编码为applicationjson的请求，你可以启用emulateJSON选项。启用该选项后，请求会以application/x-www-form-urlencoded作为MIME type，就像普通的HTML表单一样。说白了post在进行数据请求时；需要填写第三个参数{emulateJSON:true}，否则后台是无法获取你传递的参数的代码如下:1234567891011this.$http.post(&quot;http://192.168.0.192:8085/user/phonePCMessageValidation&quot;,&#123; &apos;phoneNumber&apos;:&apos;1563*****05&apos;&#125;,&#123;emulateJSON:true&#125;).then( function (res) &#123; // 处理成功的结果 console.log(res.body) &#125;,function (err) &#123; // 处理失败的结果 console.log(err) &#125;);&#125;","categories":[],"tags":[]},{"title":"Git命令","slug":"Git命令","date":"2018-01-25T03:11:26.000Z","updated":"2018-01-25T11:16:26.755Z","comments":true,"path":"2018/01/25/Git命令/","link":"","permalink":"http://yoursite.com/2018/01/25/Git命令/","excerpt":"","text":"常用操作命令1.新建代码库 在当前目录下新建一个git代码库:git init 新建一个目录,将其初始化为git代码库:git init [projectName] 下载一个项目:git clone [url] 2.配置Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置:git config –list 编辑Git配置文件:git config -e [–global] 设置提交代码时的用户信息: git config [–global] user.name “[name]” git config [–global] user.email “[email address]” 3.增加/删除文件 添加指定文件到暂存区:git add [file1] [file2] … 添加指定目录到暂存区,包括子目录:git add [dir] 添加当前目录的所有文件到暂存区:git add . 添加每个变化前,都会要求确认,对同一个文件的多处变化,可以实现分次提交: git add -p 删除工作区文件,并且将这次删除放入暂存区:git rm [file1] [file2] … 停止追踪指定文件,但该文件会保留在工作区:git rm –cached [file] 改名文件,并且将这个改名放在暂存区:git mv [file-original-name] [file-renamed] 4.代码提交 提交暂存区到仓库区:git commit -m [message] 提交暂存区的指定文件到仓库区:git commit [file1] … -m [message] 提交工作区自上次commit之后的变化，直接到仓库区:git commit -a 提交时显示所有diff信息:git commit -v 使用一次新的commit，替代上一次提交,如果代码没有任何新变化，则用来改写上一次commit的提交信息:git commit –amend -m [message] 重做上一次commit，并包括指定文件的新变化:git commit –amend [file1] [file2] … 5.分支 列出本地所有分支:git branch 列出所有远程分支:git branch -r 列出所有本地分支和远程分支:git branch -a 新建一个分支,但依然停留在当前分支: git branch [branch-name] 新建一个分支,并切换到该分支:git checkout -b [branch] 新建一个分支,指向指定commit:git branch [branch] [commit] 新建一个分支,与指定的远程分支建立追踪关系:git branch –track [branch] [remote-branch] 创建空的分支:(执行命令之前记得先提交你当前分支的修改,否则会被强制删干净,) git symbolic-ref HEAD refs/heads/[name] rm .git/index git clean -fdx 切换到指定分支,并更新工作区:git checkout [branch] [remote-branch] 切换到上一个分支:git checkout 建立追踪关系,在现有分支与指定远程分支之间:git branch –set-upstream [branch] [remote-branch] 合并指定分支到当前分支:git merge [branch] 选择一个commit,合并进当前分支:git cherry-pick [commit] 删除分支:git branch -d [branch-name] 删除远程分支: git push origin –delete [branch-name] git branch -dr [remote/branch] 6.标签 列出所有tag:git tag 新建一个tag在当前commit:git tag [tag] 新建一个tag在指定commit:git tag [tag] [commit] 删除本地tag:git tag -d [tag] 删除远程tag:git push origin :refs/tags/[tagName] 查看tag信息:git show [tag] 提交所有tag:git push [remote] –tags 提交指定tag:git push [remote] [tag] 新建一个分支,指向某个tag:git checkout -b [branch] [tag] 7.查看信息 显示有变更的文件:git status 显示当前分支的版本历史:git log 显示commit历史,以及每次commit发生变更的文件:git log –stat 搜索提交历史,根据关键词:git log -s [keywo] 显示某个commit之后的所有变动,每个commit占据一行:git log [tag] HEAD –pretty=format:%s 显示某个commit之后的所有变动,其”提交说明”必须符合搜索条件:git log [tag] HEAD –grep feature 显示过去5次提交:git log -5 –pretty –online 显示所有提交过的用户:git shortlog -sn 分支操作相关命令 查看本地分支:git branch 查看远程分支:git branch -r 创建本地分支:git branch [name] *注意新分支创建后不会自动切换为当前分支 切换分支:git checkout [name] 创建新分支并立即切换到新分支:git checkout -b[name] 删除分支:git branch -d [name] *-d选项只能删除已经参与了合并的分支，对于未合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支:git merge [name] *将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程):git push origin [name] 删除远程分支 git push origin:heads/[name]或gitpush origin:[name] 版本(tag)操作相关命令 查看版本:git tag 创建版本:git tag [name] 删除版本:git tag -d [name] 查看远程版本:git tag -r 创建远程版本(本地版本push到远程):git push origin [name] 删除远程版本:git push origin :refs/tags/[name] 合并远程仓库的tag到本地:git pull origin –tags 上传本地tag到远程仓库:git push origin –tags 创建带注释的tag:git tag -a [name] -m ‘yourMessage’ 本地代码上传到git仓库(项目迁移) 初始化:git init 添加文件到版本库中:git add . 提交文件到仓库:git commit -m ‘’ 关联到远程库:git remote add origin 远程仓库地址 获取远程仓库的内容推送到远程(如果远程库不为空必须做这一步,否则后面提交会失败):git pull –rebase origin master 推送本地库代码:git push -u origin master 状态查询:git status","categories":[],"tags":[]},{"title":"工作笔记整理","slug":"工作笔记整理","date":"2018-01-25T01:52:37.000Z","updated":"2018-05-18T02:10:27.100Z","comments":true,"path":"2018/01/25/工作笔记整理/","link":"","permalink":"http://yoursite.com/2018/01/25/工作笔记整理/","excerpt":"","text":"JS一、判断系统是否是移动端并跳转至相应页面代码如下:12345678910111213141516////判断是否移动端，如果是则跳转到指定的URL地址function browserRedirect(url) &#123; //只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值 var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; if (bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123; window.location.replace(url); &#125;&#125;browserRedirect(url);//可跳转html和jsp页面 二、获取系统时间并返回指定的日期格式 获取系统当天时间,代码如下： 1234567891011function getDay(date)&#123; date=new Date(); var y = date.getFullYear(); var m = date.getMonth()+1; var d = date.getDate(); m = m &lt; 10 ? (&apos;0&apos; + m) : m; d = d &lt; 10 ? (&apos;0&apos; + d) : d; return y +&apos;/&apos;+ m +&apos;/&apos;+ d; // return y +&apos;-&apos; + m + &apos;-&apos; + d;&#125;var date=getDay(Date()); 获取当天日期后面几天的日期,代码如下: 12345var date1=new Date();var date2=new Date(date1);date2.setDate(date1.getDate()+n);//n为要加的天数var date=getDay(date2);console.log(&apos;date&apos;+date);//date:2017/12/14+n 发送短信验证码倒计时 123456789101112131415161718let time = 60function settime(obj) &#123; if (time === 0) &#123; obj.attr(&apos;disabled&apos;, false) obj.val(&apos;获取验证码&apos;) time = 60 return &#125; obj.attr(&apos;disabled&apos;, true) obj.val(`重新发送( $&#123;time&#125; s)`) console.log(time) time-- setTimeout(() =&gt; &#123; settime(obj) &#125;, 1000)&#125;// 使用方法settime(dom) 获取url地址栏参数 jquery扩展方法代码如下: 12345678910111213(function($)&#123; $.getUrlParam=function(name)&#123; var reg=new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r=window.location.search.substr(1).match(reg); if(r != null) return unescape(r[2]); return null; &#125;&#125;)(jQuery);//使用时调用该方法即可//eg:var name=$.getUrlParam(&apos;name&apos;);var age=$.getUrlParam(&apos;age&apos;); 函数封装 123456function GetQueryString(name) &#123; const reg = new RegExp(`(^|&amp;)$&#123;name&#125;=([^&amp;]*)(&amp;|$)`) const r = window.location.search.substr(1).match(reg) if (r != null) return unescape(r[2]) return null&#125; 移动端页面调出键盘后输入框被遮挡的解决办法代码如下:12345678910$(&apos;input&apos;).bind(&apos;click&apos;,function(e)&#123; var $this = $(this); e.preventDefault(); // setTimeout(function()&#123; // $(window).scrollTop($this.offset().top - 10); // &#125;,200); setTimeout(function()&#123; document.body.scrollTop = document.body.scrollHeight; &#125;,300); &#125;) 短信链接调起本地APP或下载APP123456789101112131415161718192021222324// 判断手机系统var ua = navigator.userAgent.toLowerCase(); var t;var config = &#123; scheme_IOS: &apos;XHJD://open&apos;, scheme_Adr: &apos;xhjd://app/open&apos;, adr_download_url: &apos;http://android.myapp.com/myapp/detail.htm?apkName=com.allyoubank.xinhuagolden&apos;, ios_download_url: &apos;https://itunes.apple.com/cn/app/id1267250937?mt=8&apos;, timeout: 2000&#125;;function openApp() &#123; var startTime = Date.now(); var ifr = document.createElement(&apos;iframe&apos;); ifr.src = ua.indexOf(&apos;os&apos;) &gt; 0 ? config.scheme_IOS : config.scheme_Adr; ifr.style.display = &apos;none&apos;; document.body.appendChild(ifr); window.location.href = config.scheme_IOS t = setTimeout(function() &#123; var endTime = Date.now(); if (!startTime || endTime - startTime &lt; config.timeout + 200) &#123; console.log(&apos;您还未下载“新华金典理财”&apos;) &#125; &#125;, config.timeout)&#125; 修改a标签href属性12var href=$(&apos;a&apos;).attr(&apos;href&apos;);href=$(&apos;a&apos;).attr(&apos;href&apos;,href); CSS一、解决谷歌浏览器输入框飘黄代码如下:1234 input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px color inset; /*color值自定义*/&#125;","categories":[],"tags":[]},{"title":"NodeJs","slug":"NodeJs","date":"2018-01-25T01:48:50.000Z","updated":"2018-01-25T01:49:20.642Z","comments":true,"path":"2018/01/25/NodeJs/","link":"","permalink":"http://yoursite.com/2018/01/25/NodeJs/","excerpt":"","text":"Node.js应用的组成部分 引入required模块:使用require指令来载入Node.js模块 创建服务器:服务器可以监听客户端的请求,类似于Apache、Nginx等HTTP服务器 接收请求与响应请求:服务器很容易创建,客户端可以使用浏览器或终端发送HTTP请求,服务器接收请求后返回响应数据 Node.js创建第一个应用步骤一、引入required模块1var http=require(&quot;http&quot;); 步骤二、创建服务器接下来使用 http.createServer()方法创建服务器，并使用listen方法绑定8888端口。函数通过request，response参数来接收和相应数据。示例如下：再项目根目录下创建一个叫server.js文件，包含以下代码12345678910111213 var http=require(&quot;http&quot;); http.createServer(function(request,response)&#123; //发送http头部 //HTTP状态值：200：OK //内容类型：text/plain response.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;); //发送响应数据&quot;Hello World&quot; response.end(&apos;Hello World\\n&apos;);&#125;).listen(8888);//终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;); 分析上面代码:1.第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。2.接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。 使用npm安装模块npm安装Node.js模块语法格式如下:123npm install &lt;Module Name&gt;Node.js常用的模块expressnpm install express 安装好之后,express包就放在工程目录下的node_modules目录中,因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。1var express=require(&apos;express&apos;); 卸载模块npm uninstall express卸载后可使用命令行来查看是否卸载掉npm ls 更新模块npm update express 搜索模块npm search express 创建模块创建模块,package.json是必不可少的,使用npm生成package.json文件,生成的文件中包含了基本的结果npm init接下来使用命令在npm资源库中注册用户(使用邮箱注册):npm adduserUsername:XXXPassword:Email: Node.js REPL(交互式解释器)Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。Node自带了交互式解释器,可以执行以下任务: 读取 –读取用户输入.解析输入了JavaScript数据结构并存储在内存中 执行 –执行输入的数据结构 打印 –输出结果 循环 –循环操作以上步骤直到用户两次按下Ctrl+c按钮退出Node的交互式解释器可以很好的调试JavaScript代码 启动node:12$ node&gt; 在&gt;后面输入简单的表达式,并按下回车就可以计算结果 简单的表达式运算 使用变量 可以将数据存储在变量中,并在需要的时候使用它 变量声明使用var关键字,如果没有var关键字会直接打印出来 使用var关键字的变量可以使用console.log()来输出变量. 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：1234567891011121314 $ node &gt; var x = 0 undefined &gt; do &#123; ... x++; ... console.log(&quot;x: &quot; + x); ... &#125; while ( x &lt; 5 ); x: 1 x: 2 x: 3 x: 4 x: 5 undefined&gt; … 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线()变量*可以使用下划线获取表达式的远算结果:*12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL命令 Ctrl+c –退出当前终端 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容 停止 REPL1234$ node&gt;(^C again to quit)&gt;","categories":[],"tags":[]},{"title":"hexo基本命令","slug":"hexo基本命令","date":"2018-01-24T06:27:46.000Z","updated":"2018-01-25T04:59:19.650Z","comments":true,"path":"2018/01/24/hexo基本命令/","link":"","permalink":"http://yoursite.com/2018/01/24/hexo基本命令/","excerpt":"","text":"日常更新 本地新建文件名:hexo new “博客名” 生成文档: hexo g -d 运行本地服务器:hexo s -g ,浏览器中http://localhost:4000 同步到github:hexo d -g 卸载hexo 3.0.0版本执行:npm uninstall hexo-cli-g, 旧版本执行:npm uninstall hexo -g 安装旧版本hexo 先卸载当前版本,以2.8.3为例,执行:npm uninstall hexo@2.8.3 -g,再初始化并安装依赖和插件 安装hexo npm install hexo-cli -g hexo init blog cd blog npm install hexo server 域名绑定如果你不想使用yourusername.github.io，也可以绑定自己的域名，将域名的CNAME指向yourusername.github.io，然后在github下面新建一个CNAME文件，里面写上你的域名，然后就能通过域名直接访问到yourusername.github.io了。 安装Next主题12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装插件123456//feed插件npm install hexo-generator-feed --save//站点地图npm install hexo-generator-sitemap --save//百度站点地图npm install hexo-generator-baidu-sitemap --save SEO优化1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;","categories":[],"tags":[]}]}